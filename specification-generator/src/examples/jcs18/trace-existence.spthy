// This file contains the manual proof for the exists-trace lemma.
// This is not included in the main dnp3.m4/dnp3.spthy file as the proof
// is rather long and unwieldy to include, and isn't found quickly by
// Tamarin's autoproving functionality.

theory DNP3AsymmTraceExists begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, h/1, hmac/2, pair/2, pk/1,
           sdec/2, senc/2, sign/2, snd/1, true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

/*
looping facts with injective instances:
  L_OutSentKeyStatus/2, L_OutstationState/7, L_UserState/6
*/

restriction Eq_testing:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction InEq_testing:
  "∀ x y #i. (InEq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

restriction Unique_Pairings_id:
  "∀ x #i #j. ((Unique( x ) @ #i) ∧ (Unique( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction USR_and_OutstationID_distinct:
  "∀ x y #i.
    (Distinct( x, y ) @ #i) ⇒
    ((¬(∃ #j z. Distinct( y, z ) @ #j)) ∧
     (¬(∃ #j z. Distinct( z, x ) @ #j)))"
  // safety formula

rule (modulo E) Update_key_reveal:
   [ !F_UpdateKey( ~linkid, k ) ]
  --[ UpdateKeyReveal( k ) ]->
   [ Out( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) cdsk_reveal:
   [ !CDSKToReveal( k1 ) ] --[ CDSKReveal( k1 ) ]-> [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) mdsk_reveal:
   [ !MDSKToReveal( k1 ) ] --[ MDSKReveal( k1 ) ]-> [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) authority_symm_key_reveal:
   [ !F_AuthorityKey( k1 ) ]
  --[ AuthorityKeyReveal( k1 ) ]->
   [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) authority_asymm_priv_key_reveal:
   [ !AuthorityPrivateKey( k1 ) ]
  --[ AuthorityPrivateKeyReveal( k1 ) ]->
   [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) user_asymm_priv_key_reveal:
   [ !UserPrivateKey( k1 ) ]
  --[ UserPrivateKeyReveal( k1 ) ]->
   [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) outstation_asymm_priv_key_reveal:
   [ !OutstationPrivateKey( k1 ) ]
  --[ OutstationPrivateKeyReveal( k1 ) ]->
   [ Out( k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Authority_Symm_Key:
   [ Fr( ~AK ) ]
  --[ AuthorityCertKey( ~AK ) ]->
   [ !F_AuthorityKey( ~AK ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CountUp:
   [ L_Counter( ~id, val ) ]
  --[ NewCounterValue( ~id, h(val) ) ]->
   [
   L_Counter( ~id, h(val) ), L_XCounterValue( ~id, h(val) ),
   Out( h(val) )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A2_C_AC_Authentication_Challenge:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>, mCS,
                      'SecurityIdle'
   ),
   L_XCounterValue( ~oid, h(cCSQ) ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~CD )
   ]
  --[
  CSQ( ~oid, h(cCSQ) ), A2_nonaggressive( ~oid, 'control', ~CD ),
  A2_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>, mCS,
                      <'WaitForReply', h(cCSQ), h(cCSQ), $USR, ~CD>
   ),
   F_OutWaitForReply( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>, mCS,
                      <h(cCSQ), h(cCSQ), $USR, ~CD>
   ),
   !F_OutCCSInvariant( ~oid, ~os, <h(cCSQ), $USR, ~CD> ),
   Out( <h(cCSQ), $USR, ~CD> )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A2_M_AC_Authentication_Challenge:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>, 'SecurityIdle' ),
   L_XCounterValue( ~uid, h(mCSQ) ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~CD )
   ]
  --[
  CSQ( ~uid, h(mCSQ) ), A2_nonaggressive( ~uid, 'monitor', ~CD ),
  A2_M_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>,
                <'WaitForReply', h(mCSQ), h(mCSQ), $USR, ~CD>
   ),
   F_UserWaitForReply( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>,
                       <h(mCSQ), h(mCSQ), $USR, ~CD>
   ),
   !F_UserMCSInvariant( ~uid, ~us, <h(mCSQ), $USR, ~CD> ),
   Out( <h(mCSQ), $USR, ~CD> )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S3_SKC_session_key_change:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, 'SessionKeyChange' ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !UserUpdateKey( ~uid, ~uu, UK_i_USR_O, update_key_method,
                   auth_keys_used
   ),
   Fr( ~CDSK_j_USR_O ), Fr( ~MDSK_j_USR_O ), Fr( ~newus ),
   In( <KSQ, $USR, keystatus, CD_j> )
   ]
  --[
  SessKeys( ~CDSK_j_USR_O, ~MDSK_j_USR_O, $USR ),
  NewSKs( ~linkid, UK_i_USR_O, ~CDSK_j_USR_O, ~MDSK_j_USR_O,
          update_key_method, auth_keys_used
  ),
  Sourced_UpdateKey( ~linkid, UK_i_USR_O, update_key_method,
                     auth_keys_used
  ),
  Sourced_UpdateKey_S3_for_new_lemma( ~linkid, UK_i_USR_O,
                                      update_key_method, auth_keys_used
  ),
  UpdateKeyUsedForSKs( ~linkid, UK_i_USR_O, ~CDSK_j_USR_O,
                       ~MDSK_j_USR_O, update_key_method, auth_keys_used
  ),
  S3( ~uid, ~CDSK_j_USR_O, ~MDSK_j_USR_O ), S3_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~newus, cCS, mCS,
                <'WaitForKeyChangeConfirmation', 
                 <KSQ, $USR, 
                  senc(<~CDSK_j_USR_O, ~MDSK_j_USR_O, KSQ, $USR, keystatus, CD_j>,
                       UK_i_USR_O)
                 >, 
                 ~CDSK_j_USR_O, ~MDSK_j_USR_O>
   ),
   !F_UserSessKeys( ~uid, ~newus, 'OK', ~CDSK_j_USR_O, ~MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   ),
   !CDSKToReveal( ~CDSK_j_USR_O ), !MDSKToReveal( ~MDSK_j_USR_O ),
   Out( <KSQ, $USR, 
         senc(<~CDSK_j_USR_O, ~MDSK_j_USR_O, KSQ, $USR, keystatus, CD_j>,
              UK_i_USR_O)
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) S4_SKS_session_key_status:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>,
                      <mCSQ, mChal>, 'SecurityIdle'
   ),
   L_XCounterValue( ~oid, h(cCSQ) ),
   L_OutSentKeyStatus( ~oid, <KSQ, $USR, keystatus, CD_j> ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !OutUpdateKey( ~oid, ~ou, UK_i_USR_O, update_key_method,
                  auth_keys_used
   ),
   Fr( ~CD_j_plus_1 ), Fr( ~newos ),
   In( <KSQ, $USR, 
        senc(<CDSK_j_USR_O, MDSK_j_USR_O, KSQ, $USR, keystatus, CD_j>,
             UK_i_USR_O)
       >
   )
   ]
  --[
  GotSessKeysOutSt( ~linkid, CDSK_j_USR_O, MDSK_j_USR_O, $USR ),
  CSQ( ~oid, h(cCSQ) ),
  Sourced_UpdateKey( ~linkid, UK_i_USR_O, update_key_method,
                     auth_keys_used
  ),
  Sourced_SKs( ~linkid, UK_i_USR_O, CDSK_j_USR_O, MDSK_j_USR_O,
               update_key_method, auth_keys_used
  ),
  UpdateKeyUsedForSKs( ~linkid, UK_i_USR_O, CDSK_j_USR_O,
                       MDSK_j_USR_O, update_key_method, auth_keys_used
  ),
  S4_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, h(KSQ), ~ou, ~newos, <h(cCSQ), 'none'>,
                      <h(mCSQ), 'none'>, 'SecurityIdle'
   ),
   L_OutSentKeyStatus( ~oid,
                       <h(KSQ), $USR, 'OK', ~CD_j_plus_1, 
                        hmac(<KSQ, $USR, 
                              senc(<CDSK_j_USR_O, MDSK_j_USR_O, KSQ, $USR, keystatus, CD_j>,
                                   UK_i_USR_O)
                             >,
                             MDSK_j_USR_O)
                       >
   ),
   !F_OutSessKeys( ~oid, ~newos, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   ),
   Out( <h(KSQ), $USR, 'OK', ~CD_j_plus_1, 
         hmac(<KSQ, $USR, 
               senc(<CDSK_j_USR_O, MDSK_j_USR_O, KSQ, $USR, keystatus, CD_j>,
                    UK_i_USR_O)
              >,
              MDSK_j_USR_O)
        >
   )
   ]

  // loop breakers: [0,2]
  /* has exactly the trivial AC variant */

rule (modulo E) U2_UKCRp_Key_Change_Reply:
   [
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~CD_b )
   ]
  --[
  OutUpdateKeyChallengeActionFact( ~oid, ~linkid, ~CD_b ),
  U2_trace( ~oid )
  ]->
   [ OutUpdateKeyChallenge( ~oid, ~CD_b ), Out( <$USR, ~CD_b> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) U3_U4_U5_new_update_key_symmetric_mode:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, 'SecurityIdle' ),
   !F_UserInvariants( ~uid, ~AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_AuthorityKey( ~AK ), Fr( ~CD_a ), Fr( ~UK_i_USR_O ),
   In( <KSQ, $USR, CD_b> )
   ]
  --[
  NewUpdateKey( ~linkid, ~UK_i_USR_O, 'Symmetric', ~AK ),
  U345_symm_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS,
                <'WaitForKCC', hmac(<$OSID, ~CD_a, CD_b, KSQ>, ~UK_i_USR_O)>
   ),
   F_WaitForKCC( ~uid, ~uu, ~us, cCS, mCS,
                 hmac(<$OSID, ~CD_a, CD_b, KSQ>, ~UK_i_USR_O)
   ),
   !F_UpdateKey( ~linkid, ~UK_i_USR_O ),
   Out( <~CD_a, <KSQ, $USR, senc(<$USR, ~UK_i_USR_O, CD_b>, ~AK)>, 
         hmac(<$OSID, ~CD_a, CD_b, KSQ>, ~UK_i_USR_O)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) U3_U4_U5_new_update_key_asymmetric_mode:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, 'SecurityIdle' ),
   !F_UserInvariants( ~uid, ~AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~CD_a ), Fr( ~UK_i_USR_O ), In( <KSQ, $USR, CD_b> )
   ]
  --[
  NewUpdateKey( ~linkid, ~UK_i_USR_O, 'Asymmetric',
                <~outstation_priv_key, ~user_priv_key>
  ),
  LinkAndOutstationPrivKey( ~linkid, ~outstation_priv_key ),
  U345_asymm_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS,
                <'WaitForKCC', 
                 sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                       aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                      ~user_priv_key)
                >
   ),
   F_WaitForKCC( ~uid, ~uu, ~us, cCS, mCS,
                 sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                       aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                      ~user_priv_key)
   ),
   !F_UpdateKey( ~linkid, ~UK_i_USR_O ),
   Out( <~CD_a, 
         <KSQ, $USR, 
          aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>, 
         sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
               aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
              ~user_priv_key)
        >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S5_receive_SKS_confirmation:
   [
   L_UserState( ~uid, ~uu, ~us, <cCSQ, cChal>, <mCSQ, cChal>,
                <'WaitForKeyChangeConfirmation', SKCM_j, CDSK_j_USR_O, MDSK_j_USR_O
                >
   ),
   L_XCounterValue( ~uid, h(mCSQ) ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~cid ),
   In( <KSQ, $USR, 'OK', CD_j_plus_1, hmac(SKCM_j, MDSK_j_USR_O)> )
   ]
  --[
  GotSessKeysUser( ~linkid, CDSK_j_USR_O, MDSK_j_USR_O, $USR ),
  CSQ( ~uid, h(mCSQ) ),
  S5( ~uid, 'control', CDSK_j_USR_O, MDSK_j_USR_O ), S5_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, <h(cCSQ), 'none'>, <h(mCSQ), 'none'>,
                'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Initial_key_pre_distribution:
   [
   !F_AuthorityKey( ~AK ), Fr( ~UK_i_USR_O ), Fr( ~uid ), Fr( ~oid ),
   Fr( ~uu ), Fr( ~ou ), Fr( ~us ), Fr( ~os ), Fr( ~linkid ),
   Fr( ~user_priv_key ), Fr( ~outstation_priv_key )
   ]
  --[
  Unique( <~AK, $USR, $OUTSTATION> ),
  Unique( <~AK, $OUTSTATION, $USR> ), Distinct( $USR, $OUTSTATION ),
  AuthorityCertKey( ~AK ), NewCounterValue( ~uid, '0' ),
  NewCounterValue( ~oid, '0' ),
  NewUpdateKey( ~linkid, ~UK_i_USR_O, 'Initial', 'usb_stick' ),
  InitialA3( ~uid ), InitialA3( ~oid ),
  Sourced_UpdateKey_for_skiup_lemma( ~linkid, ~UK_i_USR_O, 'Initial',
                                     'usb_stick'
  ),
  Initial( ~oid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, <'0', 'none'>, <'0', 'none'>, 'Init'
   ),
   L_OutstationState( ~oid, '0', ~ou, ~os, <'0', 'none'>,
                      <'0', 'none'>, 'SecurityIdle'
   ),
   !F_UserInvariants( ~uid, ~AK, $USR, $OUTSTATION, ~linkid,
                      ~user_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutstationInvariants( ~oid, ~AK, $USR, $OUTSTATION, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !UserUpdateKey( ~uid, ~uu, ~UK_i_USR_O, 'Initial', 'usb_stick' ),
   !OutUpdateKey( ~oid, ~ou, ~UK_i_USR_O, 'Initial', 'usb_stick' ),
   !F_UserSessKeys( ~uid, ~us, 'NOT_INIT', 'undefined', 'undefined',
                    ~UK_i_USR_O, 'Initial', 'usb_stick'
   ),
   !F_OutSessKeys( ~oid, ~os, 'NOT_INIT', 'undefined', 'undefined',
                   ~UK_i_USR_O, 'Initial', 'usb_stick'
   ),
   L_OutSentKeyStatus( ~oid, 'none' ), L_Counter( ~uid, '0' ),
   L_Counter( ~oid, '0' ), !F_UpdateKey( ~linkid, ~UK_i_USR_O ),
   !UserPrivateKey( ~user_priv_key ),
   !OutstationPrivateKey( ~outstation_priv_key )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) S1_SKSR_session_key_status_request:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, anystate ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   )
   ]
  --[ S1_trace( ~uid ) ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, 'SessionKeyChange' ),
   Out( $USR )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S2_SKS_session_key_status:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>,
                      <mCSQ, mChal>, 'SecurityIdle'
   ),
   L_OutSentKeyStatus( ~oid, lastkeystatus ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutSessKeys( ~oid, ~os, keystatus, CDSK, MDSK, UK_i_USR_O,
                   update_key_method, auth_keys_used
   ),
   Fr( ~CD_j ), In( $USR )
   ]
  --[ S2_trace( ~oid ) ]->
   [
   L_OutstationState( ~oid, h(KSQ), ~ou, ~os, <cCSQ, cChal>,
                      <mCSQ, mChal>, 'SecurityIdle'
   ),
   L_OutSentKeyStatus( ~oid, <h(KSQ), $USR, keystatus, ~CD_j> ),
   Out( <h(KSQ), $USR, keystatus, ~CD_j> )
   ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

rule (modulo E) A3_C_AR_Authentication_Reply:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, 'SecurityIdle' ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_UserSessKeys( ~uid, ~us, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   ),
   Fr( ~cinvar ), In( <CSQ, $USR, CD> )
   ]
  --[
  SentASDU( ~linkid,
            <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>,
            'normal', 'control'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  A3_session_keys( ~linkid, CDSK_j_USR_O, MDSK_j_USR_O,
                   update_key_method, auth_keys_used
  ),
  AuthReply( <CSQ, $USR, CD>, $ASDU, CDSK_j_USR_O ),
  A3( ~uid, 'control', CDSK_j_USR_O, MDSK_j_USR_O ),
  A3_nonaggressive( ~uid, 'control', CDSK_j_USR_O, MDSK_j_USR_O, CD
  ),
  A3_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, <CSQ, ~cinvar, CSQ, $USR, CD>, mCS,
                'SecurityIdle'
   ),
   !UserCCSInvariant( ~uid, ~us, ~cinvar, <CSQ, $USR, CD> ),
   Out( <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A3_C_AR_Authentication_Aggressive:
   [
   L_UserState( ~uid, ~uu, ~us, <cCSQ, ~cinv, CSQ, $USR, CD>, mCS,
                'SecurityIdle'
   ),
   !UserCCSInvariant( ~uid, ~us, ~cinv, <CSQ, $USR, CD> ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_UserSessKeys( ~uid, ~us, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   )
   ]
  --[
  SentASDU( ~linkid,
            <h(cCSQ), $USR, 
             hmac(<'amode', h(cCSQ), <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>,
            'aggressive', 'control'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  AuthReply( <CSQ, $USR, CD>, $ASDU, CDSK_j_USR_O ),
  A3( ~uid, 'control', CDSK_j_USR_O, MDSK_j_USR_O ),
  A3_aggressive( ~uid, 'control', CDSK_j_USR_O, MDSK_j_USR_O, CD ),
  A3_Aggr_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, <h(cCSQ), ~cinv, CSQ, $USR, CD>, mCS,
                'SecurityIdle'
   ),
   Out( <h(cCSQ), $USR, 
         hmac(<'amode', h(cCSQ), <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A4_receive_C_AC_of_ASDU:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS,
                      <'WaitForReply', CSQ, CSQ, $USR, CD>
   ),
   F_OutWaitForReply( ~oid, KSQ, ~ou, ~os, cCS, mCS,
                      <CSQ, CSQ, $USR, CD>
   ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutSessKeys( ~oid, ~os, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   ),
   In( <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>
   )
   ]
  --[
  AuthASDU( ~linkid,
            <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, CDSK_j_USR_O)>,
            'normal', 'control'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  A4_C_FINISH( ), A4_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <CSQ, CSQ, $USR, CD>, mCS,
                      'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A4_idle_receive_C_AC_aggressive:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <CSQ, AC>, mCS,
                      'SecurityIdle'
   ),
   L_XCounterValue( ~oid, h(CSQ) ),
   !F_OutSessKeys( ~oid, ~os, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutCCSInvariant( ~oid, ~os, AC ),
   In( <h(CSQ), $USR, hmac(<'amode', h(CSQ), AC, $ASDU>, CDSK_j_USR_O)
       >
   )
   ]
  --[
  AuthASDU( ~linkid,
            <h(CSQ), $USR, hmac(<'amode', h(CSQ), AC, $ASDU>, CDSK_j_USR_O)>,
            'aggressive', 'control'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  CSQ( ~oid, h(CSQ) ), InEq( AC, 'none' ),
  A4_idle_aggr_receive( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <h(CSQ), AC>, mCS,
                      'SecurityIdle'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A4_waiting_receive_C_AC_aggressive:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <CSQ, h(CSQ), $USR, CD>,
                      mCS, <'WaitForReply', newChal>
   ),
   F_OutWaitForReply( ~oid, KSQ, ~ou, ~os, <CSQ, h(CSQ), $USR, CD>,
                      mCS, newChal
   ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutSessKeys( ~oid, ~os, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   ),
   !F_OutCCSInvariant( ~oid, ~os, <h(CSQ), $USR, CD> ),
   In( <h(CSQ), $USR, 
        hmac(<'amode', h(CSQ), <h(CSQ), $USR, CD>, $ASDU>, CDSK_j_USR_O)>
   )
   ]
  --[
  AuthASDU( ~linkid,
            <h(CSQ), $USR, 
             hmac(<'amode', h(CSQ), <h(CSQ), $USR, CD>, $ASDU>, CDSK_j_USR_O)>,
            'aggressive', 'control'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  InEq( <h(CSQ), $USR, CD>, 'none' ), A4_waiting_aggr_receive( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, <h(CSQ), h(CSQ), $USR, CD>,
                      mCS, 'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_OutstationWaitForReply_TimeoutorError:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS,
                      <'WaitForReply', newChal>
   ),
   F_OutWaitForReply( ~oid, KSQ, ~ou, ~os, cCS, mCS, newChal )
   ]
  -->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, newChal, mCS,
                      'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A3_M_AR_Authentication_Reply:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS, 'SecurityIdle' ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutSessKeys( ~oid, ~os, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   ),
   Fr( ~cinv ), In( <CSQ, $USR, CD> )
   ]
  --[
  SentASDU( ~linkid,
            <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>,
            'normal', 'monitor'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  AuthReply( <CSQ, $USR, CD>, $ASDU, MDSK_j_USR_O ),
  A3( ~oid, 'monitor', CDSK_j_USR_O, MDSK_j_USR_O ),
  A3_nonaggressive( ~oid, 'monitor', CDSK_j_USR_O, MDSK_j_USR_O, CD
  ),
  A3_M_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS,
                      <CSQ, ~cinv, CSQ, $USR, CD>, 'SecurityIdle'
   ),
   !OutMCSInvariant( ~oid, ~os, ~cinv, <CSQ, $USR, CD> ),
   Out( <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A3_M_AR_Authentication_Aggressive:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS,
                      <mCSQ, ~cinv, CSQ, $USR, CD>, 'SecurityIdle'
   ),
   !OutMCSInvariant( ~oid, ~os, ~cinv, <CSQ, $USR, CD> ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_OutSessKeys( ~oid, ~os, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                   UK_i_USR_O, update_key_method, auth_keys_used
   )
   ]
  --[
  SentASDU( ~linkid,
            <h(mCSQ), $USR, 
             hmac(<'amode', h(mCSQ), <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>,
            'aggressive', 'monitor'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  AuthReply( <CSQ, $USR, CD>, $ASDU, MDSK_j_USR_O ),
  A3( ~oid, 'monitor', CDSK_j_USR_O, MDSK_j_USR_O ),
  A3_aggressive( ~oid, 'monitor', CDSK_j_USR_O, MDSK_j_USR_O, CD ),
  A3_M_Aggr_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS,
                      <h(mCSQ), ~cinv, CSQ, $USR, CD>, 'SecurityIdle'
   ),
   Out( <h(mCSQ), $USR, 
         hmac(<'amode', h(mCSQ), <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A4_receive_M_AC_of_ASDU:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>,
                <'WaitForReply', CSQ, CSQ, $USR, CD>
   ),
   F_UserWaitForReply( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>,
                       <CSQ, CSQ, $USR, CD>
   ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_UserSessKeys( ~uid, ~us, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   ),
   In( <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>
   )
   ]
  --[
  AuthASDU( ~linkid,
            <CSQ, $USR, hmac(<CSQ, <CSQ, $USR, CD>, $ASDU>, MDSK_j_USR_O)>,
            'normal', 'monitor'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  A4_M_FINISH( ), A4_M_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <CSQ, CSQ, $USR, CD>,
                'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A4_idle_receive_M_AC_aggressive:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>, 'SecurityIdle' ),
   L_XCounterValue( ~uid, h(mCSQ) ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_UserSessKeys( ~uid, ~us, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   ),
   !F_UserMCSInvariant( ~uid, ~us, AC ),
   In( <h(mCSQ), $USR, 
        hmac(<'amode', h(mCSQ), mChal, $ASDU>, MDSK_j_USR_O)>
   )
   ]
  --[
  AuthASDU( ~linkid,
            <h(mCSQ), $USR, 
             hmac(<'amode', h(mCSQ), mChal, $ASDU>, MDSK_j_USR_O)>,
            'aggressive', 'monitor'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  CSQ( ~uid, h(mCSQ) ), InEq( mChal, 'none' ),
  A4_M_idle_aggr_receive( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <h(mCSQ), mChal>, 'SecurityIdle'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) A4_waiting_receive_M_AC_aggressive:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>,
                <'WaitForReply', newChal>
   ),
   F_UserWaitForReply( ~uid, ~uu, ~us, cCS, <mCSQ, mChal>, newChal ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   !F_UserSessKeys( ~uid, ~us, 'OK', CDSK_j_USR_O, MDSK_j_USR_O,
                    UK_i_USR_O, update_key_method, auth_keys_used
   ),
   !F_UserMCSInvariant( ~uid, ~us, AC ),
   In( <h(mCSQ), $USR, 
        hmac(<'amode', h(mCSQ), mChal, $ASDU>, MDSK_j_USR_O)>
   )
   ]
  --[
  AuthASDU( ~linkid,
            <h(mCSQ), $USR, 
             hmac(<'amode', h(mCSQ), mChal, $ASDU>, MDSK_j_USR_O)>,
            'aggressive', 'monitor'
  ),
  UsingSessKeys( CDSK_j_USR_O, MDSK_j_USR_O, UK_i_USR_O,
                 update_key_method, auth_keys_used
  ),
  InEq( mChal, 'none' ), A4_M_waiting_aggr_receive( ~uid )
  ]->
   [
   L_UserState( ~uid, ~uu, ~us, cCS, <h(mCSQ), mChal>, 'SecurityIdle'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_UserWaitForReply_Timeout:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS, <'WaitForReply', newChal> ),
   F_UserWaitForReply( ~uid, ~uu, ~us, cCS, mCS, newChal )
   ]
  -->
   [ L_UserState( ~uid, ~uu, ~us, cCS, newChal, 'SecurityIdle' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) U6_UKCC_Update_Key_Change_Confirmation:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS, 'SecurityIdle' ),
   OutUpdateKeyChallenge( ~oid, CD_b ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~newou ), In( CD_a ),
   In( <<h(KSQ), $USR, senc(<$USR, UK_i_USR_O, CD_b>, AK)>, 
        hmac(<$OSID, CD_a, CD_b, h(KSQ)>, UK_i_USR_O)>
   )
   ]
  --[
  OutstationUpdateKeySession( ~oid,
                              hmac(<$OSID, CD_a, CD_b, h(KSQ)>, UK_i_USR_O),
                              hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O)
  ),
  Sourced_UpdateKey( ~linkid, UK_i_USR_O, 'Symmetric', AK ),
  Sourced_UpdateKey_for_skiup_lemma_U6( ~linkid, UK_i_USR_O,
                                        'Symmetric', AK
  ),
  U6_symm_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, h(KSQ), ~newou, ~os, cCS, mCS,
                      'SecurityIdle'
   ),
   !OutUpdateKey( ~oid, ~newou, UK_i_USR_O, 'Symmetric', AK ),
   Out( hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O) )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) U7_receive_UKCC_from_Outstation:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS,
                <'WaitForKCC', hmac(<$OSID, CD_a, CD_b, KSQ>, UK_i_USR_O)>
   ),
   F_WaitForKCC( ~uid, ~uu, ~us, cCS, mCS,
                 hmac(<$OSID, CD_a, CD_b, KSQ>, UK_i_USR_O)
   ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~newuu ), In( hmac(<$USR, CD_b, CD_a, KSQ>, UK_i_USR_O) )
   ]
  --[
  UserUpdateKeySession( ~uid,
                        hmac(<$OSID, CD_a, CD_b, KSQ>, UK_i_USR_O),
                        hmac(<$USR, CD_b, CD_a, KSQ>, UK_i_USR_O)
  ),
  Sourced_UpdateKey( ~linkid, UK_i_USR_O, 'Symmetric', AK ),
  Sourced_UpdateKey_for_skiup_lemma( ~linkid, UK_i_USR_O,
                                     'Symmetric', AK
  ),
  U7_symm_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~newuu, ~us, cCS, mCS, 'SecurityIdle' ),
   !UserUpdateKey( ~uid, ~newuu, UK_i_USR_O, 'Symmetric', AK )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) U6_UKCS_Update_Key_Change_Signature:
   [
   L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS, 'SecurityIdle' ),
   OutUpdateKeyChallenge( ~oid, CD_b ),
   !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                            ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~newou ), In( CD_a ),
   In( <
        <h(KSQ), $USR, 
         aenc(<$USR, UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>, 
        ukcsu1>
   )
   ]
  --[
  Eq( verify(ukcsu1,
             <<$OSID, CD_a, CD_b, KSQ>, 
              aenc(<$USR, UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
             pk(~user_priv_key)),
      true
  ),
  Sourced_UpdateKey( ~linkid, UK_i_USR_O, 'Asymmetric',
                     <~outstation_priv_key, ~user_priv_key>
  ),
  Sourced_UpdateKey_for_skiup_lemma_U6( ~linkid, UK_i_USR_O,
                                        'Asymmetric', <~outstation_priv_key, ~user_priv_key>
  ),
  OutstationUpdateKeySession( ~oid, ukcsu1,
                              hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O)
  ),
  AsymmU6Finish( ~oid, ukcsu1,
                 hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O)
  ),
  LinkAndUserPrivKey( ~linkid, ~user_priv_key ),
  LinkAndOutstationPrivKey( ~linkid, ~outstation_priv_key ),
  U6_asymm_trace( ~oid )
  ]->
   [
   L_OutstationState( ~oid, h(KSQ), ~newou, ~os, cCS, mCS,
                      'SecurityIdle'
   ),
   !OutUpdateKey( ~oid, ~newou, UK_i_USR_O, 'Asymmetric',
                  ~outstation_priv_key
   ),
   Out( hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) U6_UKCS_Update_Key_Change_Signature:
     [
     L_OutstationState( ~oid, KSQ, ~ou, ~os, cCS, mCS, 'SecurityIdle' ),
     OutUpdateKeyChallenge( ~oid, CD_b ),
     !F_OutstationInvariants( ~oid, AK, $USR, $OSID, ~linkid,
                              ~outstation_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
     ),
     Fr( ~newou ), In( CD_a ),
     In( <
          <h(KSQ), $USR, 
           aenc(<$USR, UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>, 
          ukcsu1>
     )
     ]
    --[
    Eq( z, true ),
    Sourced_UpdateKey( ~linkid, UK_i_USR_O, 'Asymmetric',
                       <~outstation_priv_key, ~user_priv_key>
    ),
    Sourced_UpdateKey_for_skiup_lemma_U6( ~linkid, UK_i_USR_O,
                                          'Asymmetric', <~outstation_priv_key, ~user_priv_key>
    ),
    OutstationUpdateKeySession( ~oid, ukcsu1,
                                hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O)
    ),
    AsymmU6Finish( ~oid, ukcsu1,
                   hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O)
    ),
    LinkAndUserPrivKey( ~linkid, ~user_priv_key ),
    LinkAndOutstationPrivKey( ~linkid, ~outstation_priv_key ),
    U6_asymm_trace( ~oid )
    ]->
     [
     L_OutstationState( ~oid, h(KSQ), ~newou, ~os, cCS, mCS,
                        'SecurityIdle'
     ),
     !OutUpdateKey( ~oid, ~newou, UK_i_USR_O, 'Asymmetric',
                    ~outstation_priv_key
     ),
     Out( hmac(<$USR, CD_b, CD_a, h(KSQ)>, UK_i_USR_O) )
     ]
    variants (modulo AC)
    1. $OSID = $OSID.35
       $USR  = $USR.36
       ~outstation_priv_key
             = ~outstation_priv_key.42
       ~user_priv_key
             = ~user_priv_key.43
       CD_a  = CD_a.45
       CD_b  = CD_b.46
       KSQ   = KSQ.47
       UK_i_USR_O
             = UK_i_USR_O.48
       ukcsu1
             = sign(<<$OSID.35, CD_a.45, CD_b.46, KSQ.47>, 
                     aenc(<$USR.36, UK_i_USR_O.48, CD_b.46>,
                          pk(~outstation_priv_key.42))
                    >,
                    ~user_priv_key.43)
       z     = true
    
    2. $OSID = $OSID.38
       $USR  = $USR.39
       ~outstation_priv_key
             = ~outstation_priv_key.45
       ~user_priv_key
             = ~user_priv_key.46
       CD_a  = CD_a.48
       CD_b  = CD_b.49
       KSQ   = KSQ.50
       UK_i_USR_O
             = UK_i_USR_O.51
       ukcsu1
             = ukcsu1.54
       z     = verify(ukcsu1.54,
                      <<$OSID.38, CD_a.48, CD_b.49, KSQ.50>, 
                       aenc(<$USR.39, UK_i_USR_O.51, CD_b.49>,
                            pk(~outstation_priv_key.45))
                      >,
                      pk(~user_priv_key.46))
    // loop breaker: [0]
  */

rule (modulo E) U7_receive_UKCC_from_Outstation_asymm:
   [
   L_UserState( ~uid, ~uu, ~us, cCS, mCS,
                <'WaitForKCC', 
                 sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                       aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                      ~user_priv_key)
                >
   ),
   F_WaitForKCC( ~uid, ~uu, ~us, cCS, mCS,
                 sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                       aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                      ~user_priv_key)
   ),
   !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid, ~user_priv_key,
                      pk(~outstation_priv_key), pk(~user_priv_key)
   ),
   Fr( ~newuu ), In( hmac(<$USR, CD_b, ~CD_a, h(KSQ)>, ~UK_i_USR_O) )
   ]
  --[
  UserUpdateKeySession( ~uid,
                        sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                              aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                             ~user_priv_key),
                        hmac(<$USR, CD_b, ~CD_a, h(KSQ)>, ~UK_i_USR_O)
  ),
  Sourced_UpdateKey( ~linkid, ~UK_i_USR_O, 'Asymmetric',
                     <~outstation_priv_key, ~user_priv_key>
  ),
  Sourced_UpdateKey_for_skiup_lemma( ~linkid, ~UK_i_USR_O,
                                     'Asymmetric', ~outstation_priv_key
  ),
  AsymmU7Finish( ~uid, ~linkid,
                 sign(<<$OSID, ~CD_a, CD_b, KSQ>, 
                       aenc(<$USR, ~UK_i_USR_O, CD_b>, pk(~outstation_priv_key))>,
                      ~user_priv_key),
                 hmac(<$USR, CD_b, ~CD_a, h(KSQ)>, ~UK_i_USR_O)
  ),
  LinkAndUserPrivKey( ~linkid, ~user_priv_key ),
  LinkAndOutstationPrivKey( ~linkid, ~outstation_priv_key ),
  U7_asymm_trace( ~uid )
  ]->
   [
   L_UserState( ~uid, ~newuu, ~us, cCS, mCS, 'SecurityIdle' ),
   !UserUpdateKey( ~uid, ~newuu, ~UK_i_USR_O, 'Asymmetric',
                   ~outstation_priv_key
   )
   ]

  /* has exactly the trivial AC variant */

lemma countervalue_uniqueness [reuse, use_induction]:
  all-traces
  "∀ id x #i #j.
    ((NewCounterValue( id, x ) @ #i) ∧
     (NewCounterValue( id, x ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ id x #i #j.
  (NewCounterValue( id, x ) @ #i) ∧ (NewCounterValue( id, x ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma CSQ_Uniqueness [reuse, use_induction]:
  all-traces
  "∀ id csq #i #j.
    ((CSQ( id, csq ) @ #i) ∧ (CSQ( id, csq ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ id csq #i #j.
  (CSQ( id, csq ) @ #i) ∧ (CSQ( id, csq ) @ #j) ∧ ¬(#i = #j)"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( CSQ( id, csq ) @ #i )
    case A2_C_AC_Authentication_Challenge
    solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~oid, h(cCSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      next
        case A2_M_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_C_AC_aggressive
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_M_AC_aggressive
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case S4_SKS_session_key_status
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case S5_receive_SKS_confirmation
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      qed
    qed
  next
    case A2_M_AC_Authentication_Challenge
    solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~uid, h(mCSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A2_M_AC_Authentication_Challenge
        solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      next
        case A4_idle_receive_C_AC_aggressive
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_M_AC_aggressive
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case S4_SKS_session_key_status
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case S5_receive_SKS_confirmation
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      qed
    qed
  next
    case A4_idle_receive_C_AC_aggressive
    solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~oid, h(CSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
      next
        case A2_M_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_C_AC_aggressive
        solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      next
        case A4_idle_receive_M_AC_aggressive
        by solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
      next
        case S4_SKS_session_key_status
        by solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
      next
        case S5_receive_SKS_confirmation
        by solve( L_XCounterValue( ~oid, h(CSQ) ) ▶₁ #j )
      qed
    qed
  next
    case A4_idle_receive_M_AC_aggressive
    solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~uid, h(mCSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A2_M_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_C_AC_aggressive
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_M_AC_aggressive
        solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      next
        case S4_SKS_session_key_status
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case S5_receive_SKS_confirmation
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      qed
    qed
  next
    case S4_SKS_session_key_status
    solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~oid, h(cCSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case A2_M_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_C_AC_aggressive
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_M_AC_aggressive
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      next
        case S4_SKS_session_key_status
        solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      next
        case S5_receive_SKS_confirmation
        by solve( L_XCounterValue( ~oid, h(cCSQ) ) ▶₁ #j )
      qed
    qed
  next
    case S5_receive_SKS_confirmation
    solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #i )
      case CountUp
      solve( CSQ( ~uid, h(mCSQ) ) @ #j )
        case A2_C_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A2_M_AC_Authentication_Challenge
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_C_AC_aggressive
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case A4_idle_receive_M_AC_aggressive
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case S4_SKS_session_key_status
        by solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
      next
        case S5_receive_SKS_confirmation
        solve( L_XCounterValue( ~uid, h(mCSQ) ) ▶₁ #j )
          case CountUp
          by contradiction
        qed
      qed
    qed
  qed
qed

lemma exists_trace:
  exists-trace
  "∃ x x1 #a #b #c #d #e #f #g #i #j #k #l #m.
    ((((((((((((((((((((((((((((((¬(∃ ak #r.
                                     AuthorityKeyReveal( ak ) @ #r)) ∧
                                 (¬(∃ oprk #r. OutstationPrivateKeyReveal( oprk ) @ #r))) ∧
                                (¬(∃ uprk #r. UserPrivateKeyReveal( uprk ) @ #r))) ∧
                               (¬(∃ uk #r. UpdateKeyReveal( uk ) @ #r))) ∧
                              (¬(∃ cdsk #r. CDSKReveal( cdsk ) @ #r))) ∧
                             (¬(∃ mdsk #r. MDSKReveal( mdsk ) @ #r))) ∧
                            (S1_trace( x ) @ #a)) ∧
                           (S2_trace( x1 ) @ #b)) ∧
                          (S3_trace( x ) @ #c)) ∧
                         (S4_trace( x1 ) @ #d)) ∧
                        (S5_trace( x ) @ #e)) ∧
                       (A2_trace( x1 ) @ #f)) ∧
                      (A3_trace( x ) @ #g)) ∧
                     (A4_trace( x1 ) @ #i)) ∧
                    (U2_trace( x1 ) @ #j)) ∧
                   (U345_asymm_trace( x ) @ #k)) ∧
                  (U6_asymm_trace( x1 ) @ #l)) ∧
                 (U7_asymm_trace( x ) @ #m)) ∧
                (∀ id id1 #j.1 #k.1.
                  ((Initial( id ) @ #j.1) ∧ (Initial( id1 ) @ #k.1)) ⇒
                  (#j.1 = #k.1))) ∧
               (∀ id id1 #j.1 #k.1.
                 ((S1_trace( id ) @ #j.1) ∧ (S1_trace( id1 ) @ #k.1)) ⇒
                 (#j.1 = #k.1))) ∧
              (∀ id id1 #j.1 #k.1.
                ((S2_trace( id ) @ #j.1) ∧ (S2_trace( id1 ) @ #k.1)) ⇒
                (#j.1 = #k.1))) ∧
             (∀ id id1 #j.1 #k.1.
               ((S3_trace( id ) @ #j.1) ∧ (S3_trace( id1 ) @ #k.1)) ⇒
               (#j.1 = #k.1))) ∧
            (∀ id id1 #j.1 #k.1.
              ((S4_trace( id ) @ #j.1) ∧ (S4_trace( id1 ) @ #k.1)) ⇒
              (#j.1 = #k.1))) ∧
           (∀ id id1 #j.1 #k.1.
             ((S5_trace( id ) @ #j.1) ∧ (S5_trace( id1 ) @ #k.1)) ⇒
             (#j.1 = #k.1))) ∧
          (∀ id id1 #j.1 #k.1.
            ((A2_trace( id ) @ #j.1) ∧ (A2_trace( id1 ) @ #k.1)) ⇒
            (#j.1 = #k.1))) ∧
         (∀ id id1 #j.1 #k.1.
           ((A3_trace( id ) @ #j.1) ∧ (A3_trace( id1 ) @ #k.1)) ⇒
           (#j.1 = #k.1))) ∧
        (∀ id id1 #j.1 #k.1.
          ((A4_trace( id ) @ #j.1) ∧ (A4_trace( id1 ) @ #k.1)) ⇒
          (#j.1 = #k.1))) ∧
       (∀ id id1 #j.1 #k.1.
         ((U2_trace( id ) @ #j.1) ∧ (U2_trace( id1 ) @ #k.1)) ⇒
         (#j.1 = #k.1))) ∧
      (∀ id id1 #j.1 #k.1.
        ((U345_asymm_trace( id ) @ #j.1) ∧
         (U345_asymm_trace( id1 ) @ #k.1)) ⇒
        (#j.1 = #k.1))) ∧
     (∀ id id1 #j.1 #k.1.
       ((U6_asymm_trace( id ) @ #j.1) ∧ (U6_asymm_trace( id1 ) @ #k.1)) ⇒
       (#j.1 = #k.1))) ∧
    (∀ id id1 #j.1 #k.1.
      ((U7_asymm_trace( id ) @ #j.1) ∧ (U7_asymm_trace( id1 ) @ #k.1)) ⇒
      (#j.1 = #k.1))"
/*
guarded formula characterizing all satisfying traces:
"∃ x x1 #a #b #c #d #e #f #g #i #j #k #l #m.
  (S1_trace( x ) @ #a) ∧
  (S2_trace( x1 ) @ #b) ∧
  (S3_trace( x ) @ #c) ∧
  (S4_trace( x1 ) @ #d) ∧
  (S5_trace( x ) @ #e) ∧
  (A2_trace( x1 ) @ #f) ∧
  (A3_trace( x ) @ #g) ∧
  (A4_trace( x1 ) @ #i) ∧
  (U2_trace( x1 ) @ #j) ∧
  (U345_asymm_trace( x ) @ #k) ∧
  (U6_asymm_trace( x1 ) @ #l) ∧
  (U7_asymm_trace( x ) @ #m)
 ∧
  (∀ ak #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
  (∀ oprk #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
  (∀ uprk #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ⊥) ∧
  (∀ uk #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
  (∀ cdsk #r. (CDSKReveal( cdsk ) @ #r) ⇒ ⊥) ∧
  (∀ mdsk #r. (MDSKReveal( mdsk ) @ #r) ⇒ ⊥) ∧
  (∀ id id1 #j.1 #k.1.
    (Initial( id ) @ #j.1) ∧ (Initial( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (S1_trace( id ) @ #j.1) ∧ (S1_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (S2_trace( id ) @ #j.1) ∧ (S2_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (S3_trace( id ) @ #j.1) ∧ (S3_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (S4_trace( id ) @ #j.1) ∧ (S4_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (S5_trace( id ) @ #j.1) ∧ (S5_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (A2_trace( id ) @ #j.1) ∧ (A2_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (A3_trace( id ) @ #j.1) ∧ (A3_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (A4_trace( id ) @ #j.1) ∧ (A4_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (U2_trace( id ) @ #j.1) ∧ (U2_trace( id1 ) @ #k.1) ⇒ #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (U345_asymm_trace( id ) @ #j.1) ∧ (U345_asymm_trace( id1 ) @ #k.1)
   ⇒
    #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (U6_asymm_trace( id ) @ #j.1) ∧ (U6_asymm_trace( id1 ) @ #k.1)
   ⇒
    #j.1 = #k.1) ∧
  (∀ id id1 #j.1 #k.1.
    (U7_asymm_trace( id ) @ #j.1) ∧ (U7_asymm_trace( id1 ) @ #k.1)
   ⇒
    #j.1 = #k.1)"
*/
simplify
solve( !F_UserInvariants( ~uid, AK, $USR, $OSID, ~linkid,
                          ~user_priv_key, pk(~outstation_priv_key), pk(~user_priv_key)
       ) ▶₁ #a )
  case Initial_key_pre_distribution
  solve( L_UserState( ~uid, ~uu, ~us, cCS, mCS, anystate ) ▶₀ #a )
    case A2_M_AC_Authentication_Challenge
    by sorry
  next
    case A3_C_AR_Authentication_Aggressive_case_1
    by contradiction /* cyclic */
  next
    case A3_C_AR_Authentication_Aggressive_case_2
    by contradiction /* cyclic */
  next
    case A3_C_AR_Authentication_Aggressive_case_3
    by contradiction /* cyclic */
  next
    case A3_C_AR_Authentication_Reply_case_1
    by contradiction /* cyclic */
  next
    case A3_C_AR_Authentication_Reply_case_2
    by contradiction /* cyclic */
  next
    case A3_C_AR_Authentication_Reply_case_3
    by contradiction /* cyclic */
  next
    case A4_idle_receive_M_AC_aggressive_case_1
    by contradiction /* cyclic */
  next
    case A4_idle_receive_M_AC_aggressive_case_2
    by contradiction /* cyclic */
  next
    case A4_idle_receive_M_AC_aggressive_case_3
    by contradiction /* cyclic */
  next
    case A4_receive_M_AC_of_ASDU_case_1
    by contradiction /* cyclic */
  next
    case A4_receive_M_AC_of_ASDU_case_2
    by contradiction /* cyclic */
  next
    case A4_receive_M_AC_of_ASDU_case_3
    by contradiction /* cyclic */
  next
    case A4_waiting_receive_M_AC_aggressive_case_1
    by contradiction /* cyclic */
  next
    case A4_waiting_receive_M_AC_aggressive_case_2
    by contradiction /* cyclic */
  next
    case A4_waiting_receive_M_AC_aggressive_case_3
    by contradiction /* cyclic */
  next
    case A_UserWaitForReply_Timeout
    by sorry
  next
    case Initial_key_pre_distribution
    solve( !F_OutstationInvariants( ~oid, AK.1, $USR.1, $OSID.1,
                                    ~linkid.1, ~outstation_priv_key.1, pk(~outstation_priv_key.1),
                                    pk(~user_priv_key.1)
           ) ▶₂ #b )
      case Initial_key_pre_distribution
      solve( L_OutstationState( ~oid, KSQ, ~ou, ~os, <cCSQ, cChal>,
                                <mCSQ, mChal>, 'SecurityIdle'
             ) ▶₀ #b )
        case A3_M_AR_Authentication_Aggressive_case_1
        by sorry
      next
        case A3_M_AR_Authentication_Aggressive_case_2
        by sorry
      next
        case A3_M_AR_Authentication_Aggressive_case_3
        by sorry
      next
        case A3_M_AR_Authentication_Reply_case_1
        by sorry
      next
        case A3_M_AR_Authentication_Reply_case_2
        by sorry
      next
        case A3_M_AR_Authentication_Reply_case_3
        by sorry
      next
        case A4_idle_receive_C_AC_aggressive_case_1
        by sorry
      next
        case A4_idle_receive_C_AC_aggressive_case_2
        by sorry
      next
        case A4_idle_receive_C_AC_aggressive_case_3
        by sorry
      next
        case A4_receive_C_AC_of_ASDU_case_1
        by sorry
      next
        case A4_receive_C_AC_of_ASDU_case_2
        by sorry
      next
        case A4_receive_C_AC_of_ASDU_case_3
        by sorry
      next
        case A4_waiting_receive_C_AC_aggressive_case_1
        by sorry
      next
        case A4_waiting_receive_C_AC_aggressive_case_2
        by sorry
      next
        case A4_waiting_receive_C_AC_aggressive_case_3
        by sorry
      next
        case A_OutstationWaitForReply_TimeoutorError
        by sorry
      next
        case Initial_key_pre_distribution
        solve( L_OutSentKeyStatus( ~oid, lastkeystatus ) ▶₁ #b )
          case Initial_key_pre_distribution
          solve( !F_OutSessKeys( ~oid, ~os, keystatus, CDSK, MDSK,
                                 UK_i_USR_O, update_key_method, auth_keys_used
                 ) ▶₃ #b )
            case Initial_key_pre_distribution
            solve( !F_UserInvariants( ~uid, AK.1, $USR.1, $OSID.1, ~linkid.1,
                                      ~user_priv_key.1, pk(~outstation_priv_key.1),
                                      pk(~user_priv_key.1)
                   ) ▶₁ #c )
              case Initial_key_pre_distribution
              solve( !UserUpdateKey( ~uid, ~uu.1, UK_i_USR_O.1,
                                     update_key_method, auth_keys_used
                     ) ▶₂ #c )
                case Initial_key_pre_distribution
                solve( L_UserState( ~uid, ~uu, ~us.1, cCS, mCS, 'SessionKeyChange'
                       ) ▶₀ #c )
                  case S1_SKSR_session_key_status_request
                  solve( !F_OutstationInvariants( ~oid, AK.1, $USR.1, $OSID.1,
                                                  ~linkid.1, ~outstation_priv_key.1,
                                                  pk(~outstation_priv_key.1), pk(~user_priv_key.1)
                         ) ▶₃ #d )
                    case Initial_key_pre_distribution
                    solve( !OutUpdateKey( ~oid, ~ou.1, UK_i_USR_O.1, update_key_method,
                                          auth_keys_used
                           ) ▶₄ #d )
                      case Initial_key_pre_distribution
                      solve( L_OutstationState( ~oid, KSQ.1, ~ou, ~os.1, <cCSQ, cChal>,
                                                <mCSQ, mChal>, 'SecurityIdle'
                             ) ▶₀ #d )
                        case A3_M_AR_Authentication_Aggressive
                        by contradiction /* cyclic */
                      next
                        case A3_M_AR_Authentication_Reply
                        by contradiction /* cyclic */
                      next
                        case A4_idle_receive_C_AC_aggressive
                        by contradiction /* cyclic */
                      next
                        case A4_receive_C_AC_of_ASDU
                        by contradiction /* cyclic */
                      next
                        case A4_waiting_receive_C_AC_aggressive
                        by contradiction /* cyclic */
                      next
                        case A_OutstationWaitForReply_TimeoutorError
                        by sorry
                      next
                        case S2_SKS_session_key_status
                        solve( L_OutSentKeyStatus( ~oid,
                                                   <h('0'), $USR, keystatus.1, CD_j.2>
                               ) ▶₂ #d )
                          case S2_SKS_session_key_status
                          solve( L_XCounterValue( ~oid, h('0') ) ▶₁ #d )
                            case CountUp
                            solve( !F_UserInvariants( ~uid, AK.1, $USR.1, $OSID.1, ~linkid.1,
                                                      ~user_priv_key.1, pk(~outstation_priv_key.1),
                                                      pk(~user_priv_key.1)
                                   ) ▶₂ #e )
                              case Initial_key_pre_distribution
                              solve( L_UserState( ~uid, ~uu.1, ~us.1, <cCSQ, cChal>,
                                                  <mCSQ, cChal>,
                                                  <'WaitForKeyChangeConfirmation', SKCM_j, 
                                                   CDSK_j_USR_O.2, MDSK_j_USR_O.2>
                                     ) ▶₀ #e )
                                case S3_SKC_session_key_change
                                solve( L_XCounterValue( ~uid, h('0') ) ▶₁ #e )
                                  case CountUp
                                  solve( !F_OutstationInvariants( ~oid, AK.1, $USR.1, $OSID.1,
                                                                  ~linkid.1, ~outstation_priv_key.1,
                                                                  pk(~outstation_priv_key.1),
                                                                  pk(~user_priv_key.1)
                                         ) ▶₂ #f )
                                    case Initial_key_pre_distribution
                                    solve( L_OutstationState( ~oid, KSQ.2, ~ou.1, ~os.1,
                                                              <cCSQ, cChal>, mCS, 'SecurityIdle'
                                           ) ▶₀ #f )
                                      case A3_M_AR_Authentication_Aggressive
                                      by sorry
                                    next
                                      case A3_M_AR_Authentication_Reply
                                      by sorry
                                    next
                                      case A4_idle_receive_C_AC_aggressive
                                      by contradiction /* cyclic */
                                    next
                                      case S4_SKS_session_key_status
                                      solve( L_XCounterValue( ~oid, h(h('0')) ) ▶₁ #f )
                                        case CountUp
                                        solve( !F_UserInvariants( ~uid, AK.1, $USR.1, $OSID.1,
                                                                  ~linkid.1, ~user_priv_key.1,
                                                                  pk(~outstation_priv_key.1),
                                                                  pk(~user_priv_key.1)
                                               ) ▶₁ #g )
                                          case Initial_key_pre_distribution
                                          solve( !F_UserSessKeys( ~uid, ~us.1, 'OK', CDSK_j_USR_O.2,
                                                                  MDSK_j_USR_O.2, UK_i_USR_O.1,
                                                                  update_key_method, auth_keys_used
                                                 ) ▶₂ #g )
                                            case S3_SKC_session_key_change
                                            solve( L_UserState( ~uid, ~uu.1, ~newus, cCS, mCS,
                                                                'SecurityIdle'
                                                   ) ▶₀ #g )
                                              case A3_C_AR_Authentication_Aggressive
                                              by contradiction /* cyclic */
                                            next
                                              case A3_C_AR_Authentication_Reply
                                              by contradiction /* cyclic */
                                            next
                                              case A4_idle_receive_M_AC_aggressive
                                              by sorry
                                            next
                                              case A4_receive_M_AC_of_ASDU
                                              by sorry
                                            next
                                              case A4_waiting_receive_M_AC_aggressive
                                              by sorry
                                            next
                                              case A_UserWaitForReply_Timeout
                                              by sorry
                                            next
                                              case S5_receive_SKS_confirmation
                                              solve( F_OutWaitForReply( ~oid, KSQ.2, ~ou.1, ~os.1,
                                                                        cCS, mCS,
                                                                        <CSQ.1, CSQ.1, $USR.1, CD.2>
                                                     ) ▶₁ #i )
                                                case A2_C_AC_Authentication_Challenge
                                                solve( !F_OutstationInvariants( ~oid, AK.1, $USR,
                                                                                $OSID.1, ~linkid.1,
                                                                                ~outstation_priv_key.1,
                                                                                pk(~outstation_priv_key.1),
                                                                                pk(~user_priv_key.1)
                                                       ) ▶₂ #i )
                                                  case Initial_key_pre_distribution
                                                  solve( !F_OutSessKeys( ~oid, ~newos, 'OK',
                                                                         CDSK_j_USR_O.2,
                                                                         MDSK_j_USR_O.2,
                                                                         UK_i_USR_O.1,
                                                                         update_key_method,
                                                                         auth_keys_used
                                                         ) ▶₃ #i )
                                                    case S4_SKS_session_key_status
                                                    solve( !F_OutstationInvariants( ~oid, AK.1,
                                                                                    $USR.1, $OSID.1,
                                                                                    ~linkid.1,
                                                                                    ~outstation_priv_key.1,
                                                                                    pk(~outstation_priv_key.1),
                                                                                    pk(~user_priv_key.1)
                                                           ) ▶₀ #j )
                                                      case Initial_key_pre_distribution
                                                      solve( !F_UserInvariants( ~uid, ~AK.1, $USR.1,
                                                                                $OSID.1, ~linkid.1,
                                                                                ~user_priv_key.1,
                                                                                pk(~outstation_priv_key.1),
                                                                                pk(~user_priv_key.1)
                                                             ) ▶₁ #k )
                                                        case Initial_key_pre_distribution
                                                        solve( L_UserState( ~uid, ~uu.1, ~us.1, cCS,
                                                                            mCS, 'SecurityIdle'
                                                               ) ▶₀ #k )
                                                          case A3_C_AR_Authentication_Aggressive
                                                          by sorry
                                                        next
                                                          case A3_C_AR_Authentication_Reply
                                                          solve( L_OutstationState( ~oid, h(h('0')),
                                                                                    ~ou, ~newos,
                                                                                    <h('0'), 'none'
                                                                                    >,
                                                                                    <h('0'), 'none'
                                                                                    >,
                                                                                    <
                                                                                     'WaitForReply', 
                                                                                     h(h('0')), 
                                                                                     h(h('0')), 
                                                                                     $USR, ~CD>
                                                                 ) ▶₀ #i )
                                                            case A2_C_AC_Authentication_Challenge
                                                            solve( !F_OutstationInvariants( ~oid,
                                                                                            AK.1,
                                                                                            $USR.1,
                                                                                            $OSID.1,
                                                                                            ~linkid.1,
                                                                                            ~outstation_priv_key.1,
                                                                                            pk(~outstation_priv_key.1),
                                                                                            pk(~user_priv_key.1)
                                                                   ) ▶₂ #l )
                                                              case Initial_key_pre_distribution
                                                              solve( L_OutstationState( ~oid, KSQ.3,
                                                                                        ~ou.1,
                                                                                        ~os.1, cCS,
                                                                                        mCS,
                                                                                        'SecurityIdle'
                                                                     ) ▶₀ #l )
                                                                case A3_M_AR_Authentication_Aggressive
                                                                by sorry
                                                              next
                                                                case A3_M_AR_Authentication_Reply
                                                                by sorry
                                                              next
                                                                case A4_idle_receive_C_AC_aggressive
                                                                by sorry
                                                              next
                                                                case A4_receive_C_AC_of_ASDU
                                                                solve( F_WaitForKCC( ~uid, ~uu.1,
                                                                                     ~us.1, cCS,
                                                                                     mCS,
                                                                                     sign(<
                                                                                           <
                                                                                            $OSID.1, 
                                                                                            ~CD_a.2, 
                                                                                            CD_b.3, 
                                                                                            KSQ.3>, 
                                                                                           aenc(<
                                                                                                 $USR.1, 
                                                                                                 ~UK_i_USR_O.3, 
                                                                                                 CD_b.3
                                                                                                >,
                                                                                                pk(~outstation_priv_key.1))
                                                                                          >,
                                                                                          ~user_priv_key.1)
                                                                       ) ▶₁ #m )
                                                                  case U3_U4_U5_new_update_key_asymmetric_mode
                                                                  solve( !F_UserInvariants( ~uid,
                                                                                            AK.1,
                                                                                            $USR,
                                                                                            $OSID,
                                                                                            ~linkid.1,
                                                                                            ~user_priv_key,
                                                                                            pk(~outstation_priv_key),
                                                                                            pk(~user_priv_key)
                                                                         ) ▶₂ #m )
                                                                    case Initial_key_pre_distribution
                                                                    solve( L_UserState( ~uid, ~uu,
                                                                                        ~newus,
                                                                                        <CSQ, 
                                                                                         ~cinvar, 
                                                                                         CSQ, $USR, 
                                                                                         CD.1>,
                                                                                        <h('0'), 
                                                                                         'none'>,
                                                                                        <
                                                                                         'WaitForKCC', 
                                                                                         sign(<
                                                                                               <
                                                                                                $OSID, 
                                                                                                ~CD_a, 
                                                                                                CD_b.1, 
                                                                                                KSQ.2
                                                                                               >, 
                                                                                               aenc(<
                                                                                                     $USR, 
                                                                                                     ~UK_i_USR_O.1, 
                                                                                                     CD_b.1
                                                                                                    >,
                                                                                                    pk(~outstation_priv_key))
                                                                                              >,
                                                                                              ~user_priv_key)
                                                                                        >
                                                                           ) ▶₀ #m )
                                                                      case U3_U4_U5_new_update_key_asymmetric_mode
                                                                      solve( OutUpdateKeyChallenge( ~oid,
                                                                                                    CD_b.2
                                                                             ) ▶₁ #l )
                                                                        case U2_UKCRp_Key_Change_Reply
                                                                        solve( !KU( hmac(<KSQ, 
                                                                                          $USR, 
                                                                                          senc(<
                                                                                                ~CDSK_j_USR_O, 
                                                                                                ~MDSK_j_USR_O, 
                                                                                                KSQ, 
                                                                                                $USR, 
                                                                                                keystatus, 
                                                                                                CD_j.1
                                                                                               >,
                                                                                               ~UK_i_USR_O)
                                                                                         >,
                                                                                         ~MDSK_j_USR_O)
                                                                               ) @ #vk.27 )
                                                                          case S4_SKS_session_key_status
                                                                          solve( !KU( senc(<
                                                                                            ~CDSK_j_USR_O, 
                                                                                            ~MDSK_j_USR_O, 
                                                                                            h('0'), 
                                                                                            $USR, 
                                                                                            'NOT_INIT', 
                                                                                            ~CD_j>,
                                                                                           ~UK_i_USR_O)
                                                                                 ) @ #vk.21 )
                                                                            case S3_SKC_session_key_change
                                                                            solve( !KU( hmac(<
                                                                                              h(h('0')), 
                                                                                              <
                                                                                               h(h('0')), 
                                                                                               $USR, 
                                                                                               ~CD
                                                                                              >, 
                                                                                              $ASDU.1
                                                                                             >,
                                                                                             ~CDSK_j_USR_O)
                                                                                   ) @ #vk.30 )
                                                                              case A3_C_AR_Authentication_Reply
                                                                              solve( !KU( sign(<
                                                                                                <
                                                                                                 $OSID, 
                                                                                                 CD_a.1, 
                                                                                                 ~CD_b, 
                                                                                                 h(h('0'))
                                                                                                >, 
                                                                                                aenc(<
                                                                                                      $USR, 
                                                                                                      UK_i_USR_O.2, 
                                                                                                      ~CD_b
                                                                                                     >,
                                                                                                     pk(~outstation_priv_key))
                                                                                               >,
                                                                                               ~user_priv_key)
                                                                                     ) @ #vk.35 )
                                                                                case U3_U4_U5_new_update_key_asymmetric_mode
                                                                                solve( !KU( aenc(<
                                                                                                  $USR, 
                                                                                                  ~UK_i_USR_O.1, 
                                                                                                  ~CD_b
                                                                                                 >,
                                                                                                 pk(~outstation_priv_key))
                                                                                       ) @ #vk.34 )
                                                                                  case U3_U4_U5_new_update_key_asymmetric_mode
                                                                                  solve( L_Counter( ~oid,
                                                                                                    '0'
                                                                                         ) ▶₀ #vr.2 )
                                                                                    case Initial_key_pre_distribution
                                                                                    solve( !KU( hmac(<
                                                                                                      $USR, 
                                                                                                      ~CD_b, 
                                                                                                      ~CD_a, 
                                                                                                      h(h(h('0')))
                                                                                                     >,
                                                                                                     ~UK_i_USR_O.1)
                                                                                           ) @ #vk.35 )
                                                                                      case U6_UKCS_Update_Key_Change_Signature
                                                                                      solve( L_Counter( ~uid,
                                                                                                        '0'
                                                                                             ) ▶₀ #vr.3 )
                                                                                        case Initial_key_pre_distribution
                                                                                        solve( L_Counter( ~oid,
                                                                                                          h('0')
                                                                                               ) ▶₀ #vr.4 )
                                                                                          case CountUp
                                                                                          solve( !KU( ~CD_j
                                                                                                 ) @ #vk.27 )
                                                                                            case S2_SKS_session_key_status
                                                                                            solve( !KU( ~CD
                                                                                                   ) @ #vk.32 )
                                                                                              case A2_C_AC_Authentication_Challenge
                                                                                              solve( !KU( ~CD_b
                                                                                                     ) @ #vk.33 )
                                                                                                case U2_UKCRp_Key_Change_Reply
                                                                                                solve( !KU( ~CD_a
                                                                                                       ) @ #vk.34 )
                                                                                                  case U3_U4_U5_new_update_key_asymmetric_mode
                                                                                                  solve( !KU( h(h(h('0')))
                                                                                                         ) @ #vk.35 )
                                                                                                    case A2_M_AC_Authentication_Challenge
                                                                                                    by contradiction
                                                                                                       /*
                                                                                                       forbidden KD-fact
                                                                                                       */
                                                                                                  next
                                                                                                    case A3_C_AR_Authentication_Aggressive
                                                                                                    by contradiction
                                                                                                       /*
                                                                                                       forbidden KD-fact
                                                                                                       */
                                                                                                  next
                                                                                                    case A3_M_AR_Authentication_Aggressive
                                                                                                    by contradiction
                                                                                                       /*
                                                                                                       forbidden KD-fact
                                                                                                       */
                                                                                                  next
                                                                                                    case CountUp
                                                                                                    by contradiction
                                                                                                       /*
                                                                                                       forbidden KD-fact
                                                                                                       */
                                                                                                  next
                                                                                                    case c_h
                                                                                                    solve( !KU( h('0')
                                                                                                           ) @ #vk.30 )
                                                                                                      case A3_C_AR_Authentication_Aggressive
                                                                                                      by contradiction
                                                                                                         /*
                                                                                                         cyclic
                                                                                                         */
                                                                                                    next
                                                                                                      case A3_M_AR_Authentication_Aggressive
                                                                                                      by contradiction
                                                                                                         /*
                                                                                                         cyclic
                                                                                                         */
                                                                                                    next
                                                                                                      case CountUp
                                                                                                      by contradiction
                                                                                                         /*
                                                                                                         forbidden KD-fact
                                                                                                         */
                                                                                                    next
                                                                                                      case S2_SKS_session_key_status
                                                                                                      by contradiction
                                                                                                         /*
                                                                                                         forbidden KD-fact
                                                                                                         */
                                                                                                    next
                                                                                                      case c_h
                                                                                                      solve( !KU( h(h('0'))
                                                                                                             ) @ #vk.35 )
                                                                                                        case A2_C_AC_Authentication_Challenge
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           forbidden KD-fact
                                                                                                           */
                                                                                                      next
                                                                                                        case A2_M_AC_Authentication_Challenge
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           forbidden KD-fact
                                                                                                           */
                                                                                                      next
                                                                                                        case A3_C_AR_Authentication_Aggressive
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           cyclic
                                                                                                           */
                                                                                                      next
                                                                                                        case A3_M_AR_Authentication_Aggressive
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           forbidden KD-fact
                                                                                                           */
                                                                                                      next
                                                                                                        case CountUp
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           forbidden KD-fact
                                                                                                           */
                                                                                                      next
                                                                                                        case S4_SKS_session_key_status
                                                                                                        by contradiction
                                                                                                           /*
                                                                                                           forbidden KD-fact
                                                                                                           */
                                                                                                      next
                                                                                                        case c_h
                                                                                                        SOLVED // trace found
                                                                                                      qed
                                                                                                    qed
                                                                                                  qed
                                                                                                qed
                                                                                              qed
                                                                                            qed
                                                                                          qed
                                                                                        qed
                                                                                      qed
                                                                                    next
                                                                                      case c_hmac
                                                                                      by sorry
                                                                                    qed
                                                                                  qed
                                                                                next
                                                                                  case c_aenc
                                                                                  by sorry
                                                                                qed
                                                                              next
                                                                                case c_sign
                                                                                by sorry
                                                                              qed
                                                                            next
                                                                              case c_hmac
                                                                              by sorry
                                                                            qed
                                                                          next
                                                                            case c_senc
                                                                            by sorry
                                                                          qed
                                                                        next
                                                                          case c_hmac
                                                                          by sorry
                                                                        qed
                                                                      qed
                                                                    qed
                                                                  qed
                                                                qed
                                                              next
                                                                case U6_UKCC_Update_Key_Change_Confirmation
                                                                by sorry
                                                              qed
                                                            qed
                                                          qed
                                                        next
                                                          case A4_idle_receive_M_AC_aggressive
                                                          by sorry
                                                        next
                                                          case A4_receive_M_AC_of_ASDU
                                                          by sorry
                                                        next
                                                          case A4_waiting_receive_M_AC_aggressive
                                                          by sorry
                                                        next
                                                          case A_UserWaitForReply_Timeout
                                                          by sorry
                                                        next
                                                          case U7_receive_UKCC_from_Outstation
                                                          by sorry
                                                        next
                                                          case U7_receive_UKCC_from_Outstation_asymm
                                                          by contradiction /* cyclic */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case U7_receive_UKCC_from_Outstation
                                              by sorry
                                            next
                                              case U7_receive_UKCC_from_Outstation_asymm
                                              by sorry
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case U6_UKCC_Update_Key_Change_Confirmation
                                      by sorry
                                    next
                                      case U6_UKCS_Update_Key_Change_Signature
                                      by sorry
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    next
                      case U6_UKCC_Update_Key_Change_Confirmation
                      by sorry
                    next
                      case U6_UKCS_Update_Key_Change_Signature
                      by sorry
                    qed
                  qed
                qed
              next
                case U7_receive_UKCC_from_Outstation
                by sorry
              next
                case U7_receive_UKCC_from_Outstation_asymm
                by sorry
              qed
            qed
          qed
        next
          case S2_SKS_session_key_status
          by contradiction /* cyclic */
        next
          case S4_SKS_session_key_status_case_1
          by contradiction /* non-injective facts (#vr,#d,#b) */
        next
          case S4_SKS_session_key_status_case_2
          by contradiction /* non-injective facts (#vr,#d,#b) */
        next
          case S4_SKS_session_key_status_case_3
          by contradiction /* non-injective facts (#vr,#d,#b) */
        qed
      next
        case S4_SKS_session_key_status_case_1
        by sorry
      next
        case S4_SKS_session_key_status_case_2
        by sorry
      next
        case S4_SKS_session_key_status_case_3
        by sorry
      next
        case U6_UKCC_Update_Key_Change_Confirmation
        by sorry
      next
        case U6_UKCS_Update_Key_Change_Signature
        by sorry
      qed
    qed
  next
    case S1_SKSR_session_key_status_request
    by contradiction /* cyclic */
  next
    case S3_SKC_session_key_change_case_1
    by contradiction /* cyclic */
  next
    case S3_SKC_session_key_change_case_2
    by contradiction /* cyclic */
  next
    case S3_SKC_session_key_change_case_3
    by contradiction /* cyclic */
  next
    case U3_U4_U5_new_update_key_asymmetric_mode
    by sorry
  next
    case U3_U4_U5_new_update_key_symmetric_mode
    by sorry
  next
    case U7_receive_UKCC_from_Outstation
    by sorry
  next
    case U7_receive_UKCC_from_Outstation_asymm
    by sorry
  qed
qed

lemma sessions_unique [reuse]:
  all-traces
  "∀ id ar mode mode2 direction #i #j.
    ((AuthASDU( id, ar, mode, direction ) @ #i) ∧
     (AuthASDU( id, ar, mode2, direction ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ id ar mode mode2 direction #i #j.
  (AuthASDU( id, ar, mode, direction ) @ #i) ∧
  (AuthASDU( id, ar, mode2, direction ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma update_key_sourced [reuse, use_induction]:
  all-traces
  "(∀ id uk ak #i.
     (((¬(∃ #r. (AuthorityKeyReveal( ak ) @ #r) ∧ (#r < #i))) ∧
       (¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i)))) ∧
      (Sourced_UpdateKey( id, uk, 'Symmetric', ak ) @ #i)) ⇒
     (∃ #j.
       (NewUpdateKey( id, uk, 'Symmetric', ak ) @ #j) ∧ (#j < #i))) ∧
   (∀ id uk oprk uprk #i.
     ((¬(∃ #r. (UserPrivateKeyReveal( uprk ) @ #r) ∧ (#r < #i))) ∧
      (Sourced_UpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i)) ⇒
     (∃ #j.
       (NewUpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #j) ∧
       (#j < #i)))"
/*
guarded formula characterizing all counter-examples:
"((∃ id uk ak #i.
    (Sourced_UpdateKey( id, uk, 'Symmetric', ak ) @ #i)
   ∧
    (∀ #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #j.
      (NewUpdateKey( id, uk, 'Symmetric', ak ) @ #j) ⇒ ¬(#j < #i))) ∨
  (∃ id uk oprk uprk #i.
    (Sourced_UpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i)
   ∧
    (∀ #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #j.
      (NewUpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #j)
     ⇒
      ¬(#j < #i))))"
*/
by sorry

lemma update_key_agreement [reuse, use_induction]:
  all-traces
  "(∀ id id2 uk ak ak2 update_key_method #i #j.
     (((((¬(∃ #r. (AuthorityKeyReveal( ak ) @ #r) ∧ (#r < #i))) ∧
         (¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i)))) ∧
        (Sourced_UpdateKey( id, uk, 'Symmetric', ak ) @ #i)) ∧
       (NewUpdateKey( id2, uk, update_key_method, ak2 ) @ #j)) ∧
      (#j < #i)) ⇒
     (((id = id2) ∧ (ak = ak2)) ∧ (update_key_method = 'Symmetric'))) ∧
   (∀ id id2 uk oprk oprk2 uprk uprk2 update_key_method #i #j.
     ((((¬(∃ #r. (UserPrivateKeyReveal( uprk ) @ #r) ∧ (#r < #i))) ∧
        (Sourced_UpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i)) ∧
       (NewUpdateKey( id2, uk, update_key_method, <oprk2, uprk2>
        ) @ #j)) ∧
      (#j < #i)) ⇒
     ((((id = id2) ∧ (oprk = oprk2)) ∧ (uprk = uprk2)) ∧
      (update_key_method = 'Asymmetric')))"
/*
guarded formula characterizing all counter-examples:
"((∃ id id2 uk ak ak2 update_key_method #i #j.
    (Sourced_UpdateKey( id, uk, 'Symmetric', ak ) @ #i) ∧
    (NewUpdateKey( id2, uk, update_key_method, ak2 ) @ #j)
   ∧
    (∀ #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (#j < #i) ∧
    (((¬(id = id2)) ∨
      (¬(ak = ak2)) ∨
      (¬(update_key_method = 'Symmetric'))))) ∨
  (∃ id id2 uk oprk oprk2 uprk uprk2 update_key_method #i #j.
    (Sourced_UpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i) ∧
    (NewUpdateKey( id2, uk, update_key_method, <oprk2, uprk2> ) @ #j)
   ∧
    (∀ #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (#j < #i) ∧
    (((¬(id = id2)) ∨
      (¬(oprk = oprk2)) ∨
      (¬(uprk = uprk2)) ∨
      (¬(update_key_method = 'Asymmetric'))))))"
*/
by sorry

lemma update_key_secrecy [use_induction]:
  all-traces
  "((∀ id uk #i.
      ((¬(∃ #r. UpdateKeyReveal( uk ) @ #r)) ∧
       (NewUpdateKey( id, uk, 'Initial', 'usb_stick' ) @ #i)) ⇒
      (¬(∃ #j. K( uk ) @ #j))) ∧
    (∀ id uk ak #i.
      (((¬(∃ #r. AuthorityKeyReveal( ak ) @ #r)) ∧
        (¬(∃ #r. UpdateKeyReveal( uk ) @ #r))) ∧
       (NewUpdateKey( id, uk, 'Symmetric', ak ) @ #i)) ⇒
      (¬(∃ #j. K( uk ) @ #j)))) ∧
   (∀ id uk oprk uprk #i.
     (((¬(∃ #r. OutstationPrivateKeyReveal( oprk ) @ #r)) ∧
       (¬(∃ #r. UpdateKeyReveal( uk ) @ #r))) ∧
      (NewUpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i)) ⇒
     (¬(∃ #j. K( uk ) @ #j)))"
/*
guarded formula characterizing all counter-examples:
"((∃ id uk #i.
    (NewUpdateKey( id, uk, 'Initial', 'usb_stick' ) @ #i)
   ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∃ #j. (K( uk ) @ #j))) ∨
  (∃ id uk ak #i.
    (NewUpdateKey( id, uk, 'Symmetric', ak ) @ #i)
   ∧
    (∀ #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∃ #j. (K( uk ) @ #j))) ∨
  (∃ id uk oprk uprk #i.
    (NewUpdateKey( id, uk, 'Asymmetric', <oprk, uprk> ) @ #i)
   ∧
    (∀ #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∃ #j. (K( uk ) @ #j))))"
*/
by sorry

lemma session_key_secrecy [use_induction]:
  all-traces
  "((∀ id uk cdsk mdsk #i.
      ((((¬(∃ #r. UpdateKeyReveal( uk ) @ #r)) ∧
         (¬(∃ #r. CDSKReveal( cdsk ) @ #r))) ∧
        (¬(∃ #r. MDSKReveal( mdsk ) @ #r))) ∧
       (Sourced_SKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #i)) ⇒
      (¬((∃ #j. K( cdsk ) @ #j) ∨ (∃ #j. K( mdsk ) @ #j)))) ∧
    (∀ id uk ak cdsk mdsk #i.
      (((((¬(∃ #r. AuthorityKeyReveal( ak ) @ #r)) ∧
          (¬(∃ #r. UpdateKeyReveal( uk ) @ #r))) ∧
         (¬(∃ #r. CDSKReveal( cdsk ) @ #r))) ∧
        (¬(∃ #r. MDSKReveal( mdsk ) @ #r))) ∧
       (Sourced_SKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #i)) ⇒
      (¬((∃ #j. K( cdsk ) @ #j) ∨ (∃ #j. K( mdsk ) @ #j))))) ∧
   (∀ id uk cdsk mdsk oprk #i.
     (((((¬(∃ #r. OutstationPrivateKeyReveal( oprk ) @ #r)) ∧
         (¬(∃ #r. UpdateKeyReveal( uk ) @ #r))) ∧
        (¬(∃ #r. CDSKReveal( cdsk ) @ #r))) ∧
       (¬(∃ #r. MDSKReveal( mdsk ) @ #r))) ∧
      (Sourced_SKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #i)) ⇒
     (¬((∃ #j. K( cdsk ) @ #j) ∨ (∃ #j. K( mdsk ) @ #j))))"
/*
guarded formula characterizing all counter-examples:
"((∃ id uk cdsk mdsk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #i)
   ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (CDSKReveal( cdsk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (MDSKReveal( mdsk ) @ #r) ⇒ ⊥) ∧
    (((∃ #j. (K( cdsk ) @ #j)) ∨ (∃ #j. (K( mdsk ) @ #j))))) ∨
  (∃ id uk ak cdsk mdsk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #i)
   ∧
    (∀ #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (CDSKReveal( cdsk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (MDSKReveal( mdsk ) @ #r) ⇒ ⊥) ∧
    (((∃ #j. (K( cdsk ) @ #j)) ∨ (∃ #j. (K( mdsk ) @ #j))))) ∨
  (∃ id uk cdsk mdsk oprk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #i)
   ∧
    (∀ #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (CDSKReveal( cdsk ) @ #r) ⇒ ⊥) ∧
    (∀ #r. (MDSKReveal( mdsk ) @ #r) ⇒ ⊥) ∧
    (((∃ #j. (K( cdsk ) @ #j)) ∨ (∃ #j. (K( mdsk ) @ #j))))))"
*/
by sorry

lemma sessionkeys_sourced [reuse, use_induction]:
  all-traces
  "((∀ id uk cdsk mdsk #i.
      ((¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i))) ∧
       (Sourced_SKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #i)) ⇒
      (∃ #j.
        (NewSKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #j) ∧
        (#j < #i))) ∧
    (∀ id uk ak cdsk mdsk #i.
      (((¬(∃ #r. (AuthorityKeyReveal( ak ) @ #r) ∧ (#r < #i))) ∧
        (¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i)))) ∧
       (Sourced_SKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #i)) ⇒
      (∃ #j.
        (NewSKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #j) ∧
        (#j < #i)))) ∧
   (∀ id uk cdsk mdsk oprk #i.
     (((¬(∃ #r.
           (OutstationPrivateKeyReveal( oprk ) @ #r) ∧ (#r < #i))) ∧
       (¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i)))) ∧
      (Sourced_SKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #i)) ⇒
     (∃ #j.
       (NewSKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #j) ∧
       (#j < #i)))"
/*
guarded formula characterizing all counter-examples:
"((∃ id uk cdsk mdsk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #i)
   ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #j.
      (NewSKs( id, uk, cdsk, mdsk, 'Initial', 'usb_stick' ) @ #j)
     ⇒
      ¬(#j < #i))) ∨
  (∃ id uk ak cdsk mdsk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #i)
   ∧
    (∀ #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #j.
      (NewSKs( id, uk, cdsk, mdsk, 'Symmetric', ak ) @ #j)
     ⇒
      ¬(#j < #i))) ∨
  (∃ id uk cdsk mdsk oprk #i.
    (Sourced_SKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #i)
   ∧
    (∀ #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
    (∀ #j.
      (NewSKs( id, uk, cdsk, mdsk, 'Asymmetric', oprk ) @ #j)
     ⇒
      ¬(#j < #i))))"
*/
by sorry

lemma skiup_agreement [reuse, use_induction]:
  all-traces
  "∀ id id2 uk uk2 cdsk mdsk type source type2 source2 #i #j.
    ((((((¬(∃ #r. (UpdateKeyReveal( uk ) @ #r) ∧ (#r < #i))) ∧
         ((¬(type = 'Asymmetric')) ∨
          (¬(∃ #r. OutstationPrivateKeyReveal( source ) @ #r)))) ∧
        ((¬(type = 'Symmetric')) ∨
         (¬(∃ #r. AuthorityKeyReveal( source ) @ #r)))) ∧
       (Sourced_SKs( id, uk, cdsk, mdsk, type, source ) @ #i)) ∧
      (NewSKs( id2, uk2, cdsk, mdsk, type2, source2 ) @ #j)) ∧
     (#j < #i)) ⇒
    ((((id = id2) ∧ (uk = uk2)) ∧ (type = type2)) ∧
     (source = source2))"
/*
guarded formula characterizing all counter-examples:
"∃ id id2 uk uk2 cdsk mdsk type source type2 source2 #i #j.
  (Sourced_SKs( id, uk, cdsk, mdsk, type, source ) @ #i) ∧
  (NewSKs( id2, uk2, cdsk, mdsk, type2, source2 ) @ #j)
 ∧
  (∀ #r. (UpdateKeyReveal( uk ) @ #r) ⇒ ¬(#r < #i)) ∧
  (((¬(type = 'Asymmetric')) ∨
    (∀ #r. (OutstationPrivateKeyReveal( source ) @ #r) ⇒ ⊥))) ∧
  (((¬(type = 'Symmetric')) ∨
    (∀ #r. (AuthorityKeyReveal( source ) @ #r) ⇒ ⊥))) ∧
  (#j < #i) ∧
  (((¬(id = id2)) ∨
    (¬(uk = uk2)) ∨
    (¬(type = type2)) ∨
    (¬(source = source2))))"
*/
by sorry

lemma asdu_agreement_implies_mode_agreement [hide_lemma=update_key_sourced,
                                             hide_lemma=sessionkeys_sourced]:
  all-traces
  "(((¬(∃ ak #r. AuthorityKeyReveal( ak ) @ #r)) ∧
     (¬(∃ oprk #r. OutstationPrivateKeyReveal( oprk ) @ #r))) ∧
    (¬(∃ uprk #r. UserPrivateKeyReveal( uprk ) @ #r))) ⇒
   (∀ linkid ar mode direction linkid2 mode2 direction2 #i #j.
     ((((∀ cdsk mdsk uk type source.
          (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i) ⇒
          (((¬(∃ #kr. (UpdateKeyReveal( uk ) @ #kr) ∧ (#kr < #i))) ∧
            ((direction = 'control') ⇒
             (¬(∃ #skr. (CDSKReveal( cdsk ) @ #skr) ∧ (#skr < #i))))) ∧
           ((direction = 'monitor') ⇒
            (¬(∃ #skr. (MDSKReveal( mdsk ) @ #skr) ∧ (#skr < #i)))))) ∧
        (AuthASDU( linkid, ar, mode, direction ) @ #i)) ∧
       (SentASDU( linkid2, ar, mode2, direction2 ) @ #j)) ∧
      (#j < #i)) ⇒
     (((mode = mode2) ∧ (direction = direction2)) ∧
      (linkid = linkid2)))"
/*
guarded formula characterizing all counter-examples:
"(∀ ak #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
 (∀ oprk #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
 (∀ uprk #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ⊥) ∧
 (∃ linkid ar mode direction linkid2 mode2 direction2 #i #j.
   (AuthASDU( linkid, ar, mode, direction ) @ #i) ∧
   (SentASDU( linkid2, ar, mode2, direction2 ) @ #j)
  ∧
   (∀ cdsk mdsk uk type source.
     (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i)
    ⇒
     (∀ #kr. (UpdateKeyReveal( uk ) @ #kr) ⇒ ¬(#kr < #i)) ∧
     (((¬(direction = 'control')) ∨
       (∀ #skr. (CDSKReveal( cdsk ) @ #skr) ⇒ ¬(#skr < #i)))) ∧
     (((¬(direction = 'monitor')) ∨
       (∀ #skr. (MDSKReveal( mdsk ) @ #skr) ⇒ ¬(#skr < #i))))) ∧
   (#j < #i) ∧
   (((¬(mode = mode2)) ∨
     (¬(direction = direction2)) ∨
     (¬(linkid = linkid2)))))"
*/
by sorry

lemma asdu_aliveness [use_induction, hide_lemma=update_key_sourced,
                      hide_lemma=sessionkeys_sourced]:
  all-traces
  "(((¬(∃ ak #r. AuthorityKeyReveal( ak ) @ #r)) ∧
     (¬(∃ oprk #r. OutstationPrivateKeyReveal( oprk ) @ #r))) ∧
    (¬(∃ uprk #r. UserPrivateKeyReveal( uprk ) @ #r))) ⇒
   (∀ linkid ar mode direction #i.
     ((∀ cdsk mdsk uk type source.
        (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i) ⇒
        (((∀ uk.1 #k.
            (UpdateKeyUsedForSKs( linkid, uk.1, cdsk, mdsk, type, source
             ) @ #k) ⇒
            (¬(∃ #kr. (UpdateKeyReveal( uk.1 ) @ #kr) ∧ (#kr < #i)))) ∧
          ((direction = 'control') ⇒
           (¬(∃ #skr. (CDSKReveal( cdsk ) @ #skr) ∧ (#skr < #i))))) ∧
         ((direction = 'monitor') ⇒
          (¬(∃ #skr. (MDSKReveal( mdsk ) @ #skr) ∧ (#skr < #i)))))) ∧
      (AuthASDU( linkid, ar, mode, direction ) @ #i)) ⇒
     (∃ #j.
       (SentASDU( linkid, ar, mode, direction ) @ #j) ∧ (#j < #i)))"
/*
guarded formula characterizing all counter-examples:
"(∀ ak #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
 (∀ oprk #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
 (∀ uprk #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ⊥) ∧
 (∃ linkid ar mode direction #i.
   (AuthASDU( linkid, ar, mode, direction ) @ #i)
  ∧
   (∀ cdsk mdsk uk type source.
     (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i)
    ⇒
     (∀ uk.1 #k.
       (UpdateKeyUsedForSKs( linkid, uk.1, cdsk, mdsk, type, source
        ) @ #k)
      ⇒
       ∀ #kr. (UpdateKeyReveal( uk.1 ) @ #kr) ⇒ ¬(#kr < #i)) ∧
     (((¬(direction = 'control')) ∨
       (∀ #skr. (CDSKReveal( cdsk ) @ #skr) ⇒ ¬(#skr < #i)))) ∧
     (((¬(direction = 'monitor')) ∨
       (∀ #skr. (MDSKReveal( mdsk ) @ #skr) ⇒ ¬(#skr < #i))))) ∧
   (∀ #j.
     (SentASDU( linkid, ar, mode, direction ) @ #j) ⇒ ¬(#j < #i)))"
*/
by sorry

lemma asdu_injective_agreement:
  all-traces
  "(((¬(∃ ak #r. AuthorityKeyReveal( ak ) @ #r)) ∧
     (¬(∃ oprk #r. OutstationPrivateKeyReveal( oprk ) @ #r))) ∧
    (¬(∃ uprk #r. UserPrivateKeyReveal( uprk ) @ #r))) ⇒
   (∀ linkid ar mode direction #i #j.
     ((((∀ cdsk mdsk uk type source.
          (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i) ⇒
          (((∀ uk.1 #k.
              (UpdateKeyUsedForSKs( linkid, uk.1, cdsk, mdsk, type, source
               ) @ #k) ⇒
              (¬(∃ #kr. (UpdateKeyReveal( uk.1 ) @ #kr) ∧ (#kr < #i)))) ∧
            ((direction = 'control') ⇒
             (¬(∃ #skr. (CDSKReveal( cdsk ) @ #skr) ∧ (#skr < #i))))) ∧
           ((direction = 'monitor') ⇒
            (¬(∃ #skr. (MDSKReveal( mdsk ) @ #skr) ∧ (#skr < #i)))))) ∧
        (AuthASDU( linkid, ar, mode, direction ) @ #i)) ∧
       (SentASDU( linkid, ar, mode, direction ) @ #j)) ∧
      (#j < #i)) ⇒
     (¬(∃ #k.
         (AuthASDU( linkid, ar, mode, direction ) @ #k) ∧ (¬(#k = #i)))))"
/*
guarded formula characterizing all counter-examples:
"(∀ ak #r. (AuthorityKeyReveal( ak ) @ #r) ⇒ ⊥) ∧
 (∀ oprk #r. (OutstationPrivateKeyReveal( oprk ) @ #r) ⇒ ⊥) ∧
 (∀ uprk #r. (UserPrivateKeyReveal( uprk ) @ #r) ⇒ ⊥) ∧
 (∃ linkid ar mode direction #i #j.
   (AuthASDU( linkid, ar, mode, direction ) @ #i) ∧
   (SentASDU( linkid, ar, mode, direction ) @ #j)
  ∧
   (∀ cdsk mdsk uk type source.
     (UsingSessKeys( cdsk, mdsk, uk, type, source ) @ #i)
    ⇒
     (∀ uk.1 #k.
       (UpdateKeyUsedForSKs( linkid, uk.1, cdsk, mdsk, type, source
        ) @ #k)
      ⇒
       ∀ #kr. (UpdateKeyReveal( uk.1 ) @ #kr) ⇒ ¬(#kr < #i)) ∧
     (((¬(direction = 'control')) ∨
       (∀ #skr. (CDSKReveal( cdsk ) @ #skr) ⇒ ¬(#skr < #i)))) ∧
     (((¬(direction = 'monitor')) ∨
       (∀ #skr. (MDSKReveal( mdsk ) @ #skr) ⇒ ¬(#skr < #i))))) ∧
   (#j < #i) ∧
   (∃ #k.
     (AuthASDU( linkid, ar, mode, direction ) @ #k) ∧ ¬(#k = #i)))"
*/
by sorry

/* All well-formedness checks were successful. */

end