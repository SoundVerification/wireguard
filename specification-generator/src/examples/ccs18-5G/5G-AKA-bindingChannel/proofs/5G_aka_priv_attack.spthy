theory 5G_aka_priv begin

// Function signature and definition of the equational theory E

builtins: multiset, xor
functions: KDF/2, SHA256/2, adec/2, aenc/2, f1/2, f1_star/2, f2/2,
           f3/2, f4/2, f5/2, f5_star/2, fst/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2

rule (modulo E) send_secure:
   [ SndS( A, B, m ) ] --> [ Sec( A, B, m ) ]

rule (modulo E) receive_secure:
   [ Sec( A, B, m ) ] --> [ RcvS( A, B, m ) ]

rule (modulo E) init_servNet:
   [ Fr( ~idSN ) ]
  --[ ServNet( ~idSN ) ]->
   [ !SEAF( ~idSN, <'5G', ~idSN> ), Out( <'5G', ~idSN> ) ]

rule (modulo E) init_homeNet:
   [ Fr( ~sk_HN ), Fr( ~idHN ) ]
  --[ HomeNet( ~idHN ) ]->
   [
   !HSS( ~idHN, ~sk_HN ), !Pk( ~idHN, pk(~sk_HN) ),
   Out( <~idHN, pk(~sk_HN)> )
   ]

rule (modulo E) supi_supply:
   [ Fr( ~a ), Fr( ~b ) ]
  --[ Once( ) ]->
   [ !SUPI_Init( (~a+~b) ), SUPI( ~a ), SUPI( diff(~a, ~b) ) ]

rule (modulo E) add_subscription:
   [
   !SUPI_Init( (~supi+z) ), Fr( ~k ), Fr( ~sqn_root ),
   !HSS( ~idHN, ~sk_HN )
   ]
  --[
  Subscribe( ~supi, ~idHN ), Sqn_Create( ~supi, ~idHN, ~sqn_root )
  ]->
   [
   !Ltk_Sym( ~supi, ~idHN, ~k, ~sqn_root ),
   Sqn_UE( ~supi, ~idHN, ('1'+~sqn_root), ~sqn_root, '1' ),
   Sqn_HSS( ~supi, ~idHN, ('1'+~sqn_root), ~sqn_root, '1' )
   ]

rule (modulo E) ue_send_attachReq:
   [
   !Ltk_Sym( ~supi, ~idHN, ~k, ~sqn_root ), !Pk( ~idHN, pk_HN ),
   Fr( ~R ), Fr( ~tid )
   ]
  --[ Start_UE_Session( ~supi ) ]->
   [
   St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ),
   Out( <aenc(<~supi, ~R>, pk_HN), ~idHN> )
   ]

rule (modulo E) seaf_receive_attachReq_send_air:
   [ !SEAF( ~idSN, SNID ), Fr( ~tid ), In( <conc_supi, idHN> ) ]
  --[ Start_SEAF_Session( ~idSN ) ]->
   [
   St_1_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN ),
   SndS( ~idSN, idHN, <'air', <conc_supi, idHN>, SNID> )
   ]

rule (modulo E) hss_receive_air_send_aia:
   [
   !HSS( ~idHN, ~sk_HN ),
   RcvS( idSN, ~idHN,
         <'air', <aenc(<~supi, ~R>, pk(~sk_HN)), ~idHN>, '5G', idSN>
   ),
   !Ltk_Sym( ~supi, ~idHN, ~k, ~sqn_root ),
   Sqn_HSS( ~supi, ~idHN, SqnHSS, ~sqn_root, count ), Fr( ~RAND ),
   Fr( ~tid ), In( count )
   ]
  --[
  Sqn_HSS_Invariance( ~idHN, ~supi, ('1'+SqnHSS), ~sqn_root,
                      ('1'+count)
  ),
  Src( ~RAND,
       <(f5(~k, ~RAND)⊕('1'+SqnHSS)), f1(~k, <('1'+SqnHSS), ~RAND>)>
  ),
  Start_HSS_Session( ~idHN ), HSS_Send_Aia( ),
  Running( ~idHN, idSN,
           <'SEAF', 'HSS', 'K_seaf', 
            KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                    <<'5G', idSN>, (f5(~k, ~RAND)⊕('1'+SqnHSS))>),
                <'5G', idSN>)
           >
  ),
  Running( ~idHN, idSN,
           <'SEAF', 'HSS', 'RES_star', 
            KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                <<'5G', idSN>, f2(~k, ~RAND), ~RAND>)
           >
  ),
  Running( ~idHN, ~supi,
           <'UE', 'HSS', 'K_seaf', 
            KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                    <<'5G', idSN>, (f5(~k, ~RAND)⊕('1'+SqnHSS))>),
                <'5G', idSN>)
           >
  ),
  Running( ~idHN, ~supi,
           <'UE', 'HSS', 'AUTN', (f5(~k, ~RAND)⊕('1'+SqnHSS)), 
            f1(~k, <('1'+SqnHSS), ~RAND>)>
  ),
  Honest( ~supi ), Honest( ~idHN ), Honest( idSN )
  ]->
   [
   St_1_HSS( ~tid, ~idHN, ~supi,
             <aenc(<~supi, ~R>, pk(~sk_HN)), ~idHN>, idSN, <'5G', idSN>, ~k,
             ('1'+SqnHSS),
             KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                 <<'5G', idSN>, f2(~k, ~RAND), ~RAND>),
             ~RAND, ~sqn_root, ~sk_HN
   ),
   Sqn_HSS( ~supi, ~idHN, ('1'+SqnHSS), ~sqn_root, ('1'+count) ),
   SndS( ~idHN, idSN,
         <'aia', ~RAND, 
          SHA256(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                     <<'5G', idSN>, f2(~k, ~RAND), ~RAND>),
                 ~RAND), 
          KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                  <<'5G', idSN>, (f5(~k, ~RAND)⊕('1'+SqnHSS))>),
              <'5G', idSN>), 
          (f5(~k, ~RAND)⊕('1'+SqnHSS)), f1(~k, <('1'+SqnHSS), ~RAND>)>
   )
   ]

rule (modulo E) seaf_receive_aia_send_authReq:
   [
   St_1_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN ),
   RcvS( idHN, ~idSN, <'aia', RAND, HXRES_star, K_seaf, AUTN> )
   ]
  --[
  Out_Src( RAND, AUTN ),
  Running( ~idSN, idHN, <'HSS', 'SEAF', 'K_seaf', K_seaf> )
  ]->
   [
   St_2_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN, RAND, HXRES_star,
              K_seaf
   ),
   Out( <RAND, AUTN, SNID> )
   ]

rule (modulo E) ue_receive_authReq_freshness_success_send_authResp:
   [
   St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ),
   Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count ), SUPI( ~supi ),
   In( <RAND, 
        <(f5(~k, RAND)⊕(SqnUE+dif)), f1(~k, <(SqnUE+dif), RAND>)>, '5G', 
        idSN>
   )
   ]
  --[
  Original( <(f5(~k, RAND)⊕(SqnUE+dif)), f1(~k, <(SqnUE+dif), RAND>)>
  ),
  Sqn_UE_Invariance( ~supi, ~idHN, (SqnUE+dif), ~sqn_root,
                     (count+dif)
  ),
  Sqn_UE_Change( ~supi, ~idHN, (SqnUE+dif) ),
  Sqn_UE_Use( ~supi, ~idHN, (SqnUE+dif) ),
  Running( ~supi, idSN,
           <'SEAF', 'UE', 'RES_star', 
            KDF(<f3(~k, RAND), f4(~k, RAND)>,
                <<'5G', idSN>, f2(~k, RAND), RAND>)
           >
  ),
  Running( ~supi, idSN,
           <'SEAF', 'UE', 'K_seaf', 
            KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                    <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
                <'5G', idSN>)
           >
  ),
  Running( ~supi, ~idHN,
           <'HSS', 'UE', 'K_seaf', 
            KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                    <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
                <'5G', idSN>)
           >
  ),
  Running( ~supi, ~idHN, <'HSS', 'UE', 'RAND', RAND> ),
  Secret( <'UE', ~supi>, 'key',
          KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                  <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
              <'5G', idSN>)
  ),
  Secret( <'UE', ~supi>, 'supi', ~supi ),
  Commit( ~supi, ~idHN,
          <'UE', 'HSS', 'AUTN', (f5(~k, RAND)⊕(SqnUE+dif)), 
           f1(~k, <(SqnUE+dif), RAND>)>
  ),
  Commit( ~supi, ~idHN,
          <'UE', 'HSS', 'K_seaf', 
           KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                   <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
               <'5G', idSN>)
          >
  ),
  Commit( ~supi, idSN,
          <'UE', 'SEAF', 'K_seaf', 
           KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                   <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
               <'5G', idSN>)
          >
  ),
  Commit( ~supi, idSN, <'UE', 'SEAF', 'RAND', RAND> ),
  Honest( ~supi ), Honest( ~idHN ), Honest( idSN )
  ]->
   [
   St_2_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root, idSN,
            KDF(KDF(<f3(~k, RAND), f4(~k, RAND)>,
                    <<'5G', idSN>, (f5(~k, RAND)⊕(SqnUE+dif))>),
                <'5G', idSN>)
   ),
   Out( KDF(<f3(~k, RAND), f4(~k, RAND)>,
            <<'5G', idSN>, f2(~k, RAND), RAND>)
   ),
   Sqn_UE( ~supi, ~idHN, (SqnUE+dif), ~sqn_root, (count+dif) )
   ]

rule (modulo E) ue_receive_authReq_fail_freshness_send_sync_failure:
   [
   St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ),
   Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count ), SUPI( ~supi ),
   In( <RAND, <(SqnHSS⊕f5(~k, RAND)), f1(~k, <SqnHSS, RAND>)>, '5G', 
        idSN>
   ),
   In( count )
   ]
  --[
  UE_Sync_Failure( ), Findme( ),
  Replayed( <(SqnHSS⊕f5(~k, RAND)), f1(~k, <SqnHSS, RAND>)> ),
  Greater_Or_Equal_Than( SqnUE, SqnHSS ),
  Sqn_UE_Invariance( ~supi, ~idHN, SqnUE, ~sqn_root, count ),
  Sqn_UE_Nochange( ~supi, ~idHN, SqnUE )
  ]->
   [
   Out( <(SqnUE⊕f5_star(~k, RAND)), f1_star(~k, <SqnUE, RAND>)> ),
   Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count )
   ]

rule (modulo E) seaf_receive_authResp_send_ac:
   [
   St_2_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN, RAND,
              SHA256(RES_star, RAND), K_seaf
   ),
   In( RES_star )
   ]
  --[ Running( ~idSN, idHN, <'HSS', 'SEAF', 'RES_star', RES_star> )
  ]->
   [
   St_3_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN, RAND, RES_star,
              K_seaf
   ),
   SndS( ~idSN, idHN, <'ac', RES_star, <conc_supi, idHN>, SNID> )
   ]

rule (modulo E) seaf_receive_syncFailure_send_authSync:
   [
   St_2_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN, RAND, HXRES_star,
              K_seaf
   ),
   In( <SqnUEXorAKS, MACS> )
   ]
  -->
   [ SndS( ~idSN, idHN, <'resync', RAND, SqnUEXorAKS, MACS> ) ]

rule (modulo E) hss_receive_ac_send_aca:
   [
   St_1_HSS( ~tid, ~idHN, ~supi, suci, idSN, <'5G', idSN>, ~k, Sqn,
             XRES_star, ~RAND, ~sqn_root, ~sk_HN
   ),
   RcvS( idSN, ~idHN, <'ac', XRES_star, suci, '5G', idSN> )
   ]
  --[
  HSS_End( ),
  Secret( <'HSS', ~idHN>, 'key',
          KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                  <<'5G', idSN>, (Sqn⊕f5(~k, ~RAND))>),
              <'5G', idSN>)
  ),
  Commit( ~idHN, idSN,
          <'HSS', 'SEAF', 'K_seaf', 
           KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                   <<'5G', idSN>, (Sqn⊕f5(~k, ~RAND))>),
               <'5G', idSN>)
          >
  ),
  Commit( ~idHN, idSN, <'HSS', 'SEAF', 'RES_star', XRES_star> ),
  Commit( ~idHN, ~supi,
          <'HSS', 'UE', 'K_seaf', 
           KDF(KDF(<f3(~k, ~RAND), f4(~k, ~RAND)>,
                   <<'5G', idSN>, (Sqn⊕f5(~k, ~RAND))>),
               <'5G', idSN>)
          >
  ),
  Commit( ~idHN, ~supi, <'HSS', 'UE', 'RAND', ~RAND> ),
  Honest( ~idHN ), Honest( ~supi ), Honest( idSN )
  ]->
   [ SndS( ~idHN, idSN, <'aca', 'confirm', ~supi> ) ]

rule (modulo E) seaf_receive_aca:
   [
   St_3_SEAF( ~tid, ~idSN, <'5G', ~idSN>, conc_supi, idHN, ~RAND,
              RES_star, K_seaf
   ),
   RcvS( idHN, ~idSN, <'aca', 'confirm', supi> )
   ]
  --[
  SEAF_End( ),
  Running( ~idSN, supi, <'UE', 'SEAF', 'K_seaf', K_seaf> ),
  Secret( <'SEAF', ~idSN>, 'key', K_seaf ),
  Commit( ~idSN, idHN, <'SEAF', 'HSS', 'K_seaf', K_seaf> ),
  Commit( ~idSN, idHN, <'SEAF', 'HSS', 'RES_star', RES_star> ),
  Commit( ~idSN, supi, <'SEAF', 'UE', 'K_seaf', K_seaf> ),
  Commit( ~idSN, supi, <'SEAF', 'UE', 'RES_star', RES_star> ),
  Honest( supi ), Honest( idHN ), Honest( ~idSN )
  ]->
   [
   St_4_SEAF( ~tid, ~idSN, <'5G', ~idSN>, conc_supi, idHN, ~RAND,
              RES_star, K_seaf, supi
   ),
   Out( f1(K_seaf, 'SEAF') )
   ]

rule (modulo E) hss_receive_authSync:
   [
   St_1_HSS( ~tid, ~idHN, ~supi, suci, idSN, SNID, ~k, SqnHSS,
             XRES_star, ~RAND, ~sqn_root, ~sk_HN
   ),
   Sqn_HSS( ~supi, ~idHN, SqnHSS, ~sqn_root, count ),
   RcvS( idSN, ~idHN,
         <'resync', ~RAND, (f5_star(~k, ~RAND)⊕(SqnHSS+dif)), 
          f1_star(~k, <(SqnHSS+dif), ~RAND>)>
   ),
   In( (count+dif) )
   ]
  --[
  Sqn_HSS_Invariance( ~idHN, ~supi, (SqnHSS+dif), ~sqn_root,
                      (count+dif)
  ),
  HSS_Resync_End( (count+dif) )
  ]->
   [ Sqn_HSS( ~supi, ~idHN, (SqnHSS+dif), ~sqn_root, (count+dif) ) ]

restriction subscribe_once [right]:
  "∀ HN1 HN2 supi #i #j.
    ((Subscribe( supi, HN1 ) @ #i) ∧ (Subscribe( supi, HN2 ) @ #j)) ⇒
    ((#i = #j) ∧ (HN1 = HN2))"
  // safety formula

restriction subscribe_once [left]:
  "∀ HN1 HN2 supi #i #j.
    ((Subscribe( supi, HN1 ) @ #i) ∧ (Subscribe( supi, HN2 ) @ #j)) ⇒
    ((#i = #j) ∧ (HN1 = HN2))"
  // safety formula

restriction greater_or_equal_than [right]:
  "∀ x y #i.
    (Greater_Or_Equal_Than( x, y ) @ #i) ⇒ (¬(∃ z. (x+z) = y))"
  // safety formula

restriction greater_or_equal_than [left]:
  "∀ x y #i.
    (Greater_Or_Equal_Than( x, y ) @ #i) ⇒ (¬(∃ z. (x+z) = y))"
  // safety formula

restriction once [right]:
  "∀ #i #j. ((Once( ) @ #i) ∧ (Once( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction once [left]:
  "∀ #i #j. ((Once( ) @ #i) ∧ (Once( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma dummy [right]:
  all-traces "¬(⊥)"
/*
guarded formula characterizing all counter-examples:
"⊥"
*/
by sorry

lemma dummy [left]:
  all-traces "¬(⊥)"
/*
guarded formula characterizing all counter-examples:
"⊥"
*/
by contradiction

lemma rand_autn_src [right, sources]:
  all-traces
  "∀ RAND AUTN #i.
    (Out_Src( RAND, AUTN ) @ #i) ⇒
    (∃ #j. (Src( RAND, AUTN ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ RAND AUTN #i.
  (Out_Src( RAND, AUTN ) @ #i)
 ∧
  ∀ #j. (Src( RAND, AUTN ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma rand_autn_src [left, sources]:
  all-traces
  "∀ RAND AUTN #i.
    (Out_Src( RAND, AUTN ) @ #i) ⇒
    (∃ #j. (Src( RAND, AUTN ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ RAND AUTN #i.
  (Out_Src( RAND, AUTN ) @ #i)
 ∧
  ∀ #j. (Src( RAND, AUTN ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (Src( RAND, AUTN ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
    case case_1
    solve( St_1_SEAF( ~tid, ~idSN, SNID, conc_supi, idHN ) ▶₀ #i )
      case seaf_receive_attachReq_send_air
      solve( RcvS( idHN, ~idSN, <'aia', RAND, HXRES_star, K_seaf, AUTN>
             ) ▶₁ #i )
        case receive_secure_case_1
        by contradiction
      next
        case receive_secure_case_2
        by contradiction
      qed
    qed
  next
    case case_2
    by contradiction
  qed
qed

lemma sqn_ue_invariance [right, use_induction, sources]:
  all-traces
  "∀ supi HN Sqn sqn_root count #i.
    (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i) ⇒
    ((count+sqn_root) = Sqn)"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn sqn_root count #i.
  (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i)
 ∧
  ¬((count+sqn_root) = Sqn)"
*/
by sorry

lemma sqn_ue_invariance [left, use_induction, sources]:
  all-traces
  "∀ supi HN Sqn sqn_root count #i.
    (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i) ⇒
    ((count+sqn_root) = Sqn)"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn sqn_root count #i.
  (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i)
 ∧
  ¬((count+sqn_root) = Sqn)"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i )
    case ue_receive_authReq_fail_freshness_send_sync_failure
    solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i )
      case ue_send_attachReq_case_1
      solve( Sqn_UE( ~supi, ~idHN, Sqn, ~sqn_root, count ) ▶₁ #i )
        case add_subscription
        by contradiction
      next
        case ue_receive_authReq_fail_freshness_send_sync_failure_case_1
        by contradiction
      next
        case ue_receive_authReq_fail_freshness_send_sync_failure_case_2
        by contradiction
      next
        case ue_receive_authReq_freshness_success_send_authResp_case_1
        by contradiction
      next
        case ue_receive_authReq_freshness_success_send_authResp_case_2
        by contradiction
      qed
    next
      case ue_send_attachReq_case_2
      solve( Sqn_UE( ~supi, ~idHN, Sqn, ~sqn_root, count ) ▶₁ #i )
        case add_subscription
        by contradiction
      qed
    qed
  next
    case ue_receive_authReq_freshness_success_send_authResp
    solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i )
      case ue_send_attachReq_case_1
      solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count ) ▶₁ #i )
        case add_subscription
        by contradiction
      next
        case ue_receive_authReq_fail_freshness_send_sync_failure_case_1
        by contradiction
      next
        case ue_receive_authReq_fail_freshness_send_sync_failure_case_2
        by contradiction
      next
        case ue_receive_authReq_freshness_success_send_authResp_case_1
        by contradiction
      next
        case ue_receive_authReq_freshness_success_send_authResp_case_2
        by contradiction
      qed
    next
      case ue_send_attachReq_case_2
      solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count ) ▶₁ #i )
        case add_subscription
        by contradiction
      qed
    qed
  qed
qed

lemma sqn_hss_invariance [right, use_induction, sources]:
  all-traces
  "∀ HN supi Sqn sqn_root count #i.
    (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i) ⇒
    ((count+sqn_root) = Sqn)"
/*
guarded formula characterizing all counter-examples:
"∃ HN supi Sqn sqn_root count #i.
  (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i)
 ∧
  ¬((count+sqn_root) = Sqn)"
*/
by sorry

lemma sqn_hss_invariance [left, use_induction, sources]:
  all-traces
  "∀ HN supi Sqn sqn_root count #i.
    (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i) ⇒
    ((count+sqn_root) = Sqn)"
/*
guarded formula characterizing all counter-examples:
"∃ HN supi Sqn sqn_root count #i.
  (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i)
 ∧
  ¬((count+sqn_root) = Sqn)"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i )
    case hss_receive_air_send_aia
    solve( Sqn_HSS( ~supi, ~idHN, SqnHSS, ~sqn_root, count ) ▶₃ #i )
      case add_subscription_case_1
      by contradiction
    next
      case add_subscription_case_2
      by contradiction
    next
      case hss_receive_air_send_aia_case_1
      by contradiction
    next
      case hss_receive_air_send_aia_case_2
      by contradiction
    next
      case hss_receive_authSync_case_1
      by contradiction
    next
      case hss_receive_authSync_case_2
      by contradiction
    qed
  next
    case hss_receive_authSync
    solve( St_1_HSS( ~tid, ~idHN, ~supi, suci, idSN, SNID, ~k, SqnHSS,
                     XRES_star, ~RAND, ~sqn_root, ~sk_HN
           ) ▶₀ #i )
      case hss_receive_air_send_aia_case_1
      solve( Sqn_HSS( ~supi, ~idHN, ('1'+~sqn_root+count), ~sqn_root,
                      count.1
             ) ▶₁ #i )
        case hss_receive_air_send_aia
        by contradiction
      next
        case hss_receive_authSync_case_1
        by contradiction
      next
        case hss_receive_authSync_case_2
        by contradiction
      next
        case hss_receive_authSync_case_3
        by contradiction
      next
        case hss_receive_authSync_case_4
        by contradiction
      qed
    next
      case hss_receive_air_send_aia_case_2
      solve( Sqn_HSS( ~supi, ~idHN, ('1'+~sqn_root+count), ~sqn_root,
                      count.1
             ) ▶₁ #i )
        case hss_receive_air_send_aia
        by contradiction
      next
        case hss_receive_authSync_case_1
        by contradiction
      next
        case hss_receive_authSync_case_2
        by contradiction
      next
        case hss_receive_authSync_case_3
        by contradiction
      next
        case hss_receive_authSync_case_4
        by contradiction
      qed
    qed
  qed
qed

lemma sqn_ue_src [right, use_induction, reuse]:
  all-traces
  "∀ supi HN Sqn sqn_root count #i.
    (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i) ⇒
    (∃ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn sqn_root count #i.
  (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i)
 ∧
  ∀ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma sqn_ue_src [left, use_induction, reuse]:
  all-traces
  "∀ supi HN Sqn sqn_root count #i.
    (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i) ⇒
    (∃ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn sqn_root count #i.
  (Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i)
 ∧
  ∀ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( Sqn_UE_Invariance( supi, HN, Sqn, sqn_root, count ) @ #i )
    case ue_receive_authReq_fail_freshness_send_sync_failure
    solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i )
      case ue_send_attachReq_case_1
      by contradiction
    next
      case ue_send_attachReq_case_2
      by contradiction
    qed
  next
    case ue_receive_authReq_freshness_success_send_authResp
    solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i )
      case ue_send_attachReq_case_1
      by contradiction
    next
      case ue_send_attachReq_case_2
      by contradiction
    qed
  qed
qed

lemma sqn_hss_src [right, reuse]:
  all-traces
  "∀ HN supi Sqn sqn_root count #i.
    (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i) ⇒
    (∃ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ HN supi Sqn sqn_root count #i.
  (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i)
 ∧
  ∀ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma sqn_hss_src [left, reuse]:
  all-traces
  "∀ HN supi Sqn sqn_root count #i.
    (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i) ⇒
    (∃ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ HN supi Sqn sqn_root count #i.
  (Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i)
 ∧
  ∀ #j. (Sqn_Create( supi, HN, sqn_root ) @ #j) ⇒ ¬(#j < #i)"
*/
simplify
solve( Sqn_HSS_Invariance( HN, supi, Sqn, sqn_root, count ) @ #i )
  case hss_receive_air_send_aia
  solve( Sqn_HSS( ~supi, ~idHN, SqnHSS, ~sqn_root, count ) ▶₃ #i )
    case add_subscription_case_1
    by contradiction
  next
    case add_subscription_case_2
    by contradiction
  next
    case hss_receive_air_send_aia_case_1
    by contradiction
  next
    case hss_receive_air_send_aia_case_2
    by contradiction
  next
    case hss_receive_authSync_case_1
    by contradiction
  next
    case hss_receive_authSync_case_2
    by contradiction
  qed
next
  case hss_receive_authSync
  solve( St_1_HSS( ~tid, ~idHN, ~supi, suci, idSN, SNID, ~k, SqnHSS,
                   XRES_star, ~RAND, ~sqn_root, ~sk_HN
         ) ▶₀ #i )
    case hss_receive_air_send_aia_case_1
    by contradiction
  next
    case hss_receive_air_send_aia_case_2
    by contradiction
  qed
qed

lemma sqn_ue_nodecrease [right, use_induction, reuse]:
  all-traces
  "(((∀ supi HN Sqni Sqnj #i #j.
       (((Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
         (Sqn_UE_Change( supi, HN, Sqni ) @ #i)) ∧
        (#i < #j)) ⇒
       (∃ dif. Sqnj = (Sqni+dif))) ∧
     (∀ supi HN Sqni Sqnj #i #j.
       (((Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
         (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)) ∧
        (#i < #j)) ⇒
       (∃ dif. Sqnj = (Sqni+dif)))) ∧
    (∀ supi HN Sqni Sqnj #i #j.
      (((Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
        (Sqn_UE_Change( supi, HN, Sqni ) @ #i)) ∧
       (#i < #j)) ⇒
      ((Sqnj = Sqni) ∨ (∃ dif. Sqnj = (Sqni+dif))))) ∧
   (∀ supi HN Sqni Sqnj #i #j.
     (((Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
       (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)) ∧
      (#i < #j)) ⇒
     ((Sqnj = Sqni) ∨ (∃ dif. Sqnj = (Sqni+dif))))"
/*
guarded formula characterizing all counter-examples:
"((∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Change( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Change( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (¬(Sqnj = Sqni)) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (¬(Sqnj = Sqni)) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)))"
*/
by sorry

lemma sqn_ue_nodecrease [left, use_induction, reuse]:
  all-traces
  "(((∀ supi HN Sqni Sqnj #i #j.
       (((Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
         (Sqn_UE_Change( supi, HN, Sqni ) @ #i)) ∧
        (#i < #j)) ⇒
       (∃ dif. Sqnj = (Sqni+dif))) ∧
     (∀ supi HN Sqni Sqnj #i #j.
       (((Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
         (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)) ∧
        (#i < #j)) ⇒
       (∃ dif. Sqnj = (Sqni+dif)))) ∧
    (∀ supi HN Sqni Sqnj #i #j.
      (((Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
        (Sqn_UE_Change( supi, HN, Sqni ) @ #i)) ∧
       (#i < #j)) ⇒
      ((Sqnj = Sqni) ∨ (∃ dif. Sqnj = (Sqni+dif))))) ∧
   (∀ supi HN Sqni Sqnj #i #j.
     (((Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
       (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)) ∧
      (#i < #j)) ⇒
     ((Sqnj = Sqni) ∨ (∃ dif. Sqnj = (Sqni+dif))))"
/*
guarded formula characterizing all counter-examples:
"((∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Change( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Change( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Change( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (¬(Sqnj = Sqni)) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)) ∨
  (∃ supi HN Sqni Sqnj #i #j.
    (Sqn_UE_Nochange( supi, HN, Sqnj ) @ #j) ∧
    (Sqn_UE_Nochange( supi, HN, Sqni ) @ #i)
   ∧
    (#i < #j) ∧ (¬(Sqnj = Sqni)) ∧ (∀ dif. (Sqnj = (Sqni+dif)) ⇒ ⊥)))"
*/
by sorry

lemma sqn_ue_unique [right, reuse, hide_lemma=sqn_ue_src,
                     hide_lemma=sqn_hss_src]:
  all-traces
  "∀ supi HN Sqn #i #j.
    ((Sqn_UE_Use( supi, HN, Sqn ) @ #i) ∧
     (Sqn_UE_Use( supi, HN, Sqn ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn #i #j.
  (Sqn_UE_Use( supi, HN, Sqn ) @ #i) ∧
  (Sqn_UE_Use( supi, HN, Sqn ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma sqn_ue_unique [left, reuse, hide_lemma=sqn_ue_src,
                     hide_lemma=sqn_hss_src]:
  all-traces
  "∀ supi HN Sqn #i #j.
    ((Sqn_UE_Use( supi, HN, Sqn ) @ #i) ∧
     (Sqn_UE_Use( supi, HN, Sqn ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ supi HN Sqn #i #j.
  (Sqn_UE_Use( supi, HN, Sqn ) @ #i) ∧
  (Sqn_UE_Use( supi, HN, Sqn ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma ue_sync_failure [right]:
  exists-trace "∃ #i. UE_Sync_Failure( ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i. (UE_Sync_Failure( ) @ #i)"
*/
by sorry

lemma ue_sync_failure [left]:
  exists-trace "∃ #i. UE_Sync_Failure( ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i. (UE_Sync_Failure( ) @ #i)"
*/
simplify
solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i )
  case ue_send_attachReq_case_1
  solve( SUPI( ~supi ) ▶₂ #i )
    case supi_supply_case_1
    solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count ) ▶₁ #i )
      case add_subscription
      by sorry
    next
      case ue_receive_authReq_fail_freshness_send_sync_failure_case_1
      by sorry
    next
      case ue_receive_authReq_fail_freshness_send_sync_failure_case_2
      by sorry
    next
      case ue_receive_authReq_freshness_success_send_authResp
      solve( Sqn_UE( ~supi, ~idHN, (~sqn_root+count), ~sqn_root, count
             ) ▶₁ #vr.3 )
        case add_subscription
        solve( splitEqs(0) )
          case split_case_1
          solve( !KU( f1(~k, <SqnHSS, RAND>) ) @ #vk.5 )
            case c_f1
            by sorry
          next
            case seaf_receive_aia_send_authReq
            solve( RcvS( idSN.3, ~idHN,
                         <'air', <aenc(<~supi, ~R.2>, pk(~sk_HN)), ~idHN>, '5G', idSN.3>
                   ) ▶₁ #j.1 )
              case receive_secure
              solve( !KU( aenc(<~supi, ~R.1>, pk(~sk_HN)) ) @ #vk.25 )
                case c_aenc
                by sorry
              next
                case ue_send_attachReq
                solve( RcvS( idHN.1, ~idSN.1,
                             <'aia', ~RAND, HXRES_star, K_seaf, 
                              (f5(~k, ~RAND)⊕('1'+~sqn_root+count)), 
                              f1(~k, <('1'+~sqn_root+count), ~RAND>)>
                       ) ▶₁ #vr.5 )
                  case receive_secure_case_1
                  by sorry
                next
                  case receive_secure_case_2
                  solve( !KU( (f5(~k, RAND.1)⊕('1'+~sqn_root+dif)) ) @ #vk.17 )
                    case c_xor
                    by sorry
                  next
                    case coerce
                    solve( !KD( (f5(~k, RAND.1)⊕('1'+~sqn_root+dif)) ) ▶₀ #vk.2 )
                      case init_homeNet
                      by sorry
                    next
                      case init_servNet
                      by sorry
                    next
                      case seaf_receive_aca
                      by sorry
                    next
                      case seaf_receive_aia_send_authReq
                      solve( St_1_SEAF( ~tid.6, ~idSN.3, SNID, conc_supi.1, idHN.1
                             ) ▶₀ #vr.18 )
                        case seaf_receive_attachReq_send_air
                        solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                          case d_0_fst
                          by sorry
                        next
                          case d_0_snd
                          solve( RcvS( idHN.1, ~idSN.2,
                                       <'aia', RAND.2, HXRES_star, K_seaf, AUTN>
                                 ) ▶₁ #vr.18 )
                            case receive_secure_case_1
                            solve( (#vr.21, 0) ~~> (#vk.2, 0) )
                              case d_0_fst
                              solve( RcvS( ~idSN.2, ~idHN,
                                           <'air', <aenc(<~supi, ~R.3>, pk(~sk_HN)), ~idHN>, '5G', 
                                            ~idSN.2>
                                     ) ▶₁ #vr.24 )
                                case receive_secure
                                solve( (#vr.25, 0) ~~> (#vk.2, 0) )
                                  case d_0_fst
                                  solve( (#vr.29, 0) ~~> (#vk.2, 0) )
                                    case Xor
                                    solve( Sqn_HSS( ~supi, ~idHN, (~sqn_root+dif), ~sqn_root, dif
                                           ) ▶₃ #vr.24 )
                                      case add_subscription
                                      solve( Sqn_HSS( ~supi, ~idHN, (~sqn_root+count), ~sqn_root,
                                                      count
                                             ) ▶₃ #j.1 )
                                        case add_subscription
                                        solve( !KU( ~idHN ) @ #vk.19 )
                                          case init_homeNet
                                          solve( !KU( ~RAND ) @ #vk.10 )
                                            case seaf_receive_aia_send_authReq
                                            solve( RcvS( idHN.1, ~idSN.3,
                                                         <'aia', ~RAND, HXRES_star, K_seaf, 
                                                          (f5(~k, ~RAND)⊕('1'+'1'+~sqn_root)), 
                                                          f1(~k, <('1'+'1'+~sqn_root), ~RAND>)>
                                                   ) ▶₁ #vr.20 )
                                              case receive_secure
                                              SOLVED // trace found
                                            qed
                                          qed
                                        next
                                          case ue_send_attachReq_case_1
                                          by sorry
                                        next
                                          case ue_send_attachReq_case_2
                                          by sorry
                                        qed
                                      next
                                        case hss_receive_air_send_aia
                                        by sorry
                                      next
                                        case hss_receive_authSync
                                        by sorry
                                      qed
                                    next
                                      case hss_receive_air_send_aia
                                      by sorry
                                    next
                                      case hss_receive_authSync
                                      by sorry
                                    qed
                                  next
                                    case d_xor_case_1
                                    by sorry
                                  next
                                    case d_xor_case_2
                                    by sorry
                                  next
                                    case d_xor_case_3
                                    by sorry
                                  next
                                    case d_xor_case_4
                                    by sorry
                                  qed
                                next
                                  case d_0_snd
                                  by sorry
                                qed
                              qed
                            next
                              case d_0_snd
                              by sorry
                            qed
                          next
                            case receive_secure_case_2
                            by sorry
                          qed
                        qed
                      qed
                    next
                      case ue_receive_authReq_fail_freshness_send_sync_failure
                      by sorry
                    next
                      case ue_receive_authReq_freshness_success_send_authResp
                      by sorry
                    next
                      case ue_send_attachReq
                      by sorry
                    qed
                  qed
                next
                  case receive_secure_case_3
                  by sorry
                qed
              qed
            qed
          qed
        next
          case split_case_2
          by sorry
        next
          case split_case_3
          by sorry
        next
          case split_case_4
          by sorry
        qed
      qed
    qed
  next
    case supi_supply_case_2
    by sorry
  qed
next
  case ue_send_attachReq_case_2
  by solve( SUPI( ~supi ) ▶₂ #i )
qed

lemma original_replayed_autn [right]:
  exists-trace
  "∃ #i #j autn. (Original( autn ) @ #i) ∧ (Replayed( autn ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j autn. (Original( autn ) @ #i) ∧ (Replayed( autn ) @ #j)"
*/
by sorry

lemma original_replayed_autn [left]:
  exists-trace
  "∃ #i #j autn. (Original( autn ) @ #i) ∧ (Replayed( autn ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j autn. (Original( autn ) @ #i) ∧ (Replayed( autn ) @ #j)"
*/
by sorry

lemma executability_honest_replayed [right]:
  exists-trace
  "∃ #i #j.
    ((((((((SEAF_End( ) @ #i) ∧ (Findme( ) @ #j)) ∧ (#i < #j)) ∧
         (∀ supi HN sqn_root #i.1.
           (Sqn_Create( supi, HN, sqn_root ) @ #i.1) ⇒
           (¬(∃ #j.1. K( sqn_root ) @ #j.1)))) ∧
        (∀ HN1 HN2 #j.1 #k.
          ((HomeNet( HN1 ) @ #j.1) ∧ (HomeNet( HN2 ) @ #k)) ⇒ (#j.1 = #k))) ∧
       (∀ S1 S2 HN1 HN2 #j.1 #k.
         ((Subscribe( S1, HN1 ) @ #j.1) ∧ (Subscribe( S2, HN2 ) @ #k)) ⇒
         (#j.1 = #k))) ∧
      (∀ SNID1 SNID2 #j.1 #k.
        ((Start_SEAF_Session( SNID1 ) @ #j.1) ∧
         (Start_SEAF_Session( SNID2 ) @ #k)) ⇒
        (#j.1 = #k))) ∧
     (∀ UE1 UE2 #j.1 #k.
       ((Start_UE_Session( UE1 ) @ #j.1) ∧
        (Start_UE_Session( UE2 ) @ #k)) ⇒
       (#j.1 = #k))) ∧
    (∀ HN1 HN2 #j.1 #k.
      ((Start_HSS_Session( HN1 ) @ #j.1) ∧
       (Start_HSS_Session( HN2 ) @ #k)) ⇒
      (#j.1 = #k))"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j.
  (SEAF_End( ) @ #i) ∧ (Findme( ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ supi HN sqn_root #i.1.
    (Sqn_Create( supi, HN, sqn_root ) @ #i.1)
   ⇒
    ∀ #j.1. (K( sqn_root ) @ #j.1) ⇒ ⊥) ∧
  (∀ HN1 HN2 #j.1 #k.
    (HomeNet( HN1 ) @ #j.1) ∧ (HomeNet( HN2 ) @ #k) ⇒ #j.1 = #k) ∧
  (∀ S1 S2 HN1 HN2 #j.1 #k.
    (Subscribe( S1, HN1 ) @ #j.1) ∧ (Subscribe( S2, HN2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ SNID1 SNID2 #j.1 #k.
    (Start_SEAF_Session( SNID1 ) @ #j.1) ∧
    (Start_SEAF_Session( SNID2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ UE1 UE2 #j.1 #k.
    (Start_UE_Session( UE1 ) @ #j.1) ∧ (Start_UE_Session( UE2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ HN1 HN2 #j.1 #k.
    (Start_HSS_Session( HN1 ) @ #j.1) ∧ (Start_HSS_Session( HN2 ) @ #k)
   ⇒
    #j.1 = #k)"
*/
by sorry

lemma executability_honest_replayed [left]:
  exists-trace
  "∃ #i #j.
    ((((((((SEAF_End( ) @ #i) ∧ (Findme( ) @ #j)) ∧ (#i < #j)) ∧
         (∀ supi HN sqn_root #i.1.
           (Sqn_Create( supi, HN, sqn_root ) @ #i.1) ⇒
           (¬(∃ #j.1. K( sqn_root ) @ #j.1)))) ∧
        (∀ HN1 HN2 #j.1 #k.
          ((HomeNet( HN1 ) @ #j.1) ∧ (HomeNet( HN2 ) @ #k)) ⇒ (#j.1 = #k))) ∧
       (∀ S1 S2 HN1 HN2 #j.1 #k.
         ((Subscribe( S1, HN1 ) @ #j.1) ∧ (Subscribe( S2, HN2 ) @ #k)) ⇒
         (#j.1 = #k))) ∧
      (∀ SNID1 SNID2 #j.1 #k.
        ((Start_SEAF_Session( SNID1 ) @ #j.1) ∧
         (Start_SEAF_Session( SNID2 ) @ #k)) ⇒
        (#j.1 = #k))) ∧
     (∀ UE1 UE2 #j.1 #k.
       ((Start_UE_Session( UE1 ) @ #j.1) ∧
        (Start_UE_Session( UE2 ) @ #k)) ⇒
       (#j.1 = #k))) ∧
    (∀ HN1 HN2 #j.1 #k.
      ((Start_HSS_Session( HN1 ) @ #j.1) ∧
       (Start_HSS_Session( HN2 ) @ #k)) ⇒
      (#j.1 = #k))"
/*
guarded formula characterizing all satisfying traces:
"∃ #i #j.
  (SEAF_End( ) @ #i) ∧ (Findme( ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ supi HN sqn_root #i.1.
    (Sqn_Create( supi, HN, sqn_root ) @ #i.1)
   ⇒
    ∀ #j.1. (K( sqn_root ) @ #j.1) ⇒ ⊥) ∧
  (∀ HN1 HN2 #j.1 #k.
    (HomeNet( HN1 ) @ #j.1) ∧ (HomeNet( HN2 ) @ #k) ⇒ #j.1 = #k) ∧
  (∀ S1 S2 HN1 HN2 #j.1 #k.
    (Subscribe( S1, HN1 ) @ #j.1) ∧ (Subscribe( S2, HN2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ SNID1 SNID2 #j.1 #k.
    (Start_SEAF_Session( SNID1 ) @ #j.1) ∧
    (Start_SEAF_Session( SNID2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ UE1 UE2 #j.1 #k.
    (Start_UE_Session( UE1 ) @ #j.1) ∧ (Start_UE_Session( UE2 ) @ #k)
   ⇒
    #j.1 = #k) ∧
  (∀ HN1 HN2 #j.1 #k.
    (Start_HSS_Session( HN1 ) @ #j.1) ∧ (Start_HSS_Session( HN2 ) @ #k)
   ⇒
    #j.1 = #k)"
*/
by sorry

lemma findme [right]:
  exists-trace "∃ #i. Findme( ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i. (Findme( ) @ #i)"
*/
by sorry

lemma findme [left]:
  exists-trace "∃ #i. Findme( ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i. (Findme( ) @ #i)"
*/
by sorry

lemma executability_honest [right]:
  exists-trace
  "∃ #i.
    ((((((SEAF_End( ) @ #i) ∧
         (∀ supi HN sqn_root #i.1.
           (Sqn_Create( supi, HN, sqn_root ) @ #i.1) ⇒
           (¬(∃ #j. K( sqn_root ) @ #j)))) ∧
        (∀ HN1 HN2 #j #k.
          ((HomeNet( HN1 ) @ #j) ∧ (HomeNet( HN2 ) @ #k)) ⇒ (#j = #k))) ∧
       (∀ S1 S2 HN1 HN2 #j #k.
         ((Subscribe( S1, HN1 ) @ #j) ∧ (Subscribe( S2, HN2 ) @ #k)) ⇒
         (#j = #k))) ∧
      (∀ SNID1 SNID2 #j #k.
        ((Start_SEAF_Session( SNID1 ) @ #j) ∧
         (Start_SEAF_Session( SNID2 ) @ #k)) ⇒
        (#j = #k))) ∧
     (∀ UE1 UE2 #j #k.
       ((Start_UE_Session( UE1 ) @ #j) ∧ (Start_UE_Session( UE2 ) @ #k)) ⇒
       (#j = #k))) ∧
    (∀ HN1 HN2 #j #k.
      ((Start_HSS_Session( HN1 ) @ #j) ∧
       (Start_HSS_Session( HN2 ) @ #k)) ⇒
      (#j = #k))"
/*
guarded formula characterizing all satisfying traces:
"∃ #i.
  (SEAF_End( ) @ #i)
 ∧
  (∀ supi HN sqn_root #i.1.
    (Sqn_Create( supi, HN, sqn_root ) @ #i.1)
   ⇒
    ∀ #j. (K( sqn_root ) @ #j) ⇒ ⊥) ∧
  (∀ HN1 HN2 #j #k.
    (HomeNet( HN1 ) @ #j) ∧ (HomeNet( HN2 ) @ #k) ⇒ #j = #k) ∧
  (∀ S1 S2 HN1 HN2 #j #k.
    (Subscribe( S1, HN1 ) @ #j) ∧ (Subscribe( S2, HN2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ SNID1 SNID2 #j #k.
    (Start_SEAF_Session( SNID1 ) @ #j) ∧
    (Start_SEAF_Session( SNID2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ UE1 UE2 #j #k.
    (Start_UE_Session( UE1 ) @ #j) ∧ (Start_UE_Session( UE2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ HN1 HN2 #j #k.
    (Start_HSS_Session( HN1 ) @ #j) ∧ (Start_HSS_Session( HN2 ) @ #k)
   ⇒
    #j = #k)"
*/
by sorry

lemma executability_honest [left]:
  exists-trace
  "∃ #i.
    ((((((SEAF_End( ) @ #i) ∧
         (∀ supi HN sqn_root #i.1.
           (Sqn_Create( supi, HN, sqn_root ) @ #i.1) ⇒
           (¬(∃ #j. K( sqn_root ) @ #j)))) ∧
        (∀ HN1 HN2 #j #k.
          ((HomeNet( HN1 ) @ #j) ∧ (HomeNet( HN2 ) @ #k)) ⇒ (#j = #k))) ∧
       (∀ S1 S2 HN1 HN2 #j #k.
         ((Subscribe( S1, HN1 ) @ #j) ∧ (Subscribe( S2, HN2 ) @ #k)) ⇒
         (#j = #k))) ∧
      (∀ SNID1 SNID2 #j #k.
        ((Start_SEAF_Session( SNID1 ) @ #j) ∧
         (Start_SEAF_Session( SNID2 ) @ #k)) ⇒
        (#j = #k))) ∧
     (∀ UE1 UE2 #j #k.
       ((Start_UE_Session( UE1 ) @ #j) ∧ (Start_UE_Session( UE2 ) @ #k)) ⇒
       (#j = #k))) ∧
    (∀ HN1 HN2 #j #k.
      ((Start_HSS_Session( HN1 ) @ #j) ∧
       (Start_HSS_Session( HN2 ) @ #k)) ⇒
      (#j = #k))"
/*
guarded formula characterizing all satisfying traces:
"∃ #i.
  (SEAF_End( ) @ #i)
 ∧
  (∀ supi HN sqn_root #i.1.
    (Sqn_Create( supi, HN, sqn_root ) @ #i.1)
   ⇒
    ∀ #j. (K( sqn_root ) @ #j) ⇒ ⊥) ∧
  (∀ HN1 HN2 #j #k.
    (HomeNet( HN1 ) @ #j) ∧ (HomeNet( HN2 ) @ #k) ⇒ #j = #k) ∧
  (∀ S1 S2 HN1 HN2 #j #k.
    (Subscribe( S1, HN1 ) @ #j) ∧ (Subscribe( S2, HN2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ SNID1 SNID2 #j #k.
    (Start_SEAF_Session( SNID1 ) @ #j) ∧
    (Start_SEAF_Session( SNID2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ UE1 UE2 #j #k.
    (Start_UE_Session( UE1 ) @ #j) ∧ (Start_UE_Session( UE2 ) @ #k)
   ⇒
    #j = #k) ∧
  (∀ HN1 HN2 #j #k.
    (Start_HSS_Session( HN1 ) @ #j) ∧ (Start_HSS_Session( HN2 ) @ #k)
   ⇒
    #j = #k)"
*/
by sorry

diffLemma Observational_equivalence:
rule-equivalence
  case Rule_Destrd_0_adec
  by sorry
next
  case Rule_Destrd_0_fst
  by sorry
next
  case Rule_Destrd_0_snd
  by sorry
next
  case Rule_Destrd_union
  by sorry
next
  case Rule_Destrd_xor
  by sorry
next
  case Rule_Equality
  by sorry
next
  case Rule_Send
  by sorry
next
  case Rule_add_subscription
  by sorry
next
  case Rule_hss_receive_ac_send_aca
  by sorry
next
  case Rule_hss_receive_air_send_aia
  by sorry
next
  case Rule_hss_receive_authSync
  by sorry
next
  case Rule_init_homeNet
  by sorry
next
  case Rule_init_servNet
  by sorry
next
  case Rule_receive_secure
  by sorry
next
  case Rule_seaf_receive_aca
  by sorry
next
  case Rule_seaf_receive_aia_send_authReq
  by sorry
next
  case Rule_seaf_receive_attachReq_send_air
  by sorry
next
  case Rule_seaf_receive_authResp_send_ac
  by sorry
next
  case Rule_seaf_receive_syncFailure_send_authSync
  by sorry
next
  case Rule_send_secure
  by sorry
next
  case Rule_supi_supply
  by sorry
next
  case Rule_ue_receive_authReq_fail_freshness_send_sync_failure
  backward-search
    case LHS
    step( simplify )
    step( solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i ) )
      case ue_send_attachReq_case_1
      step( solve( SUPI( ~supi ) ▶₂ #i ) )
        case supi_supply_case_1
        step( solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count
                     ) ▶₁ #i ) )
          case add_subscription
          by sorry
        next
          case ue_receive_authReq_fail_freshness_send_sync_failure_case_1
          by step( contradiction )
        next
          case ue_receive_authReq_fail_freshness_send_sync_failure_case_2
          by sorry
        next
          case ue_receive_authReq_freshness_success_send_authResp
          step( solve( Sqn_UE( ~supi, ~idHN, (~sqn_root+count), ~sqn_root,
                               count
                       ) ▶₁ #vr.4 ) )
            case add_subscription
            step( solve( splitEqs(0) ) )
              case split_case_1
              step( solve( !KU( f1(~k, <SqnHSS, RAND>) ) @ #vk.11 ) )
                case c_f1
                by sorry
              next
                case seaf_receive_aia_send_authReq
                step( solve( RcvS( idSN.3, ~idHN,
                                   <'air', <aenc(<~supi, ~R.2>, pk(~sk_HN)), ~idHN>, '5G', idSN.3>
                             ) ▶₁ #j ) )
                  case receive_secure
                  step( solve( !KU( aenc(<~supi, ~R>, pk(~sk_HN)) ) @ #vk.25 ) )
                    case c_aenc
                    by sorry
                  next
                    case ue_send_attachReq
                    step( solve( RcvS( idHN.1, ~idSN.2,
                                       <'aia', ~RAND, HXRES_star, K_seaf, 
                                        (f5(~k, ~RAND)⊕('1'+~sqn_root+count)), 
                                        f1(~k, <('1'+~sqn_root+count), ~RAND>)>
                                 ) ▶₁ #vr.6 ) )
                      case receive_secure_case_1
                      by sorry
                    next
                      case receive_secure_case_2
                      step( solve( !KU( (f5(~k, RAND.1)⊕('1'+~sqn_root+dif))
                                   ) @ #vk.18 ) )
                        case c_xor
                        by sorry
                      next
                        case coerce
                        step( solve( !KD( (f5(~k, RAND.1)⊕('1'+~sqn_root+dif))
                                     ) ▶₀ #vk.13 ) )
                          case init_homeNet
                          by step( contradiction )
                        next
                          case init_servNet
                          by step( contradiction )
                        next
                          case seaf_receive_aca
                          by sorry
                        next
                          case seaf_receive_aia_send_authReq
                          step( solve( St_1_SEAF( ~tid.6, ~idSN.3, SNID, conc_supi.1, idHN.1
                                       ) ▶₀ #vr.19 ) )
                            case seaf_receive_attachReq_send_air
                            step( solve( (#vl.2, 0) ~~> (#vk.13, 0) ) )
                              case d_0_fst
                              by sorry
                            next
                              case d_0_snd
                              step( solve( RcvS( idHN.1, ~idSN.2,
                                                 <'aia', RAND.1, HXRES_star, K_seaf, AUTN>
                                           ) ▶₁ #vr.19 ) )
                                case receive_secure_case_1
                                step( solve( (#vr.22, 0) ~~> (#vk.13, 0) ) )
                                  case d_0_fst
                                  step( solve( RcvS( ~idSN.2, ~idHN,
                                                     <'air', 
                                                      <aenc(<~supi, ~R.3>, pk(~sk_HN)), ~idHN>, 
                                                      '5G', ~idSN.2>
                                               ) ▶₁ #vr.25 ) )
                                    case receive_secure
                                    step( solve( (#vr.26, 0) ~~> (#vk.13, 0) ) )
                                      case d_0_fst
                                      step( solve( (#vr.30, 0) ~~> (#vk.13, 0) ) )
                                        case Xor
                                        step( solve( Sqn_HSS( ~supi, ~idHN, (~sqn_root+count),
                                                              ~sqn_root, count
                                                     ) ▶₃ #j ) )
                                          case add_subscription
                                          step( solve( Sqn_HSS( ~supi, ~idHN, (~sqn_root+dif),
                                                                ~sqn_root, dif
                                                       ) ▶₃ #vr.25 ) )
                                            case add_subscription
                                            step( solve( !KU( ~idHN ) @ #vk.19 ) )
                                              case init_homeNet
                                              step( solve( !KU( ~RAND ) @ #vk.14 ) )
                                                case seaf_receive_aia_send_authReq
                                                step( solve( RcvS( idHN.1, ~idSN.3,
                                                                   <'aia', ~RAND, HXRES_star, 
                                                                    K_seaf, 
                                                                    (f5(~k, ~RAND)⊕
                                                                     ('1'+'1'+~sqn_root)), 
                                                                    f1(~k,
                                                                       <('1'+'1'+~sqn_root), ~RAND>)
                                                                   >
                                                             ) ▶₁ #vr.23 ) )
                                                  case receive_secure
                                                  step( solve( !KU( '5G' ) @ #vk.15 ) )
                                                    case coerce
                                                    by sorry
                                                  next
                                                    case pub
                                                    step( solve( !KU( '1' ) @ #vk.18 ) )
                                                      case coerce
                                                      by sorry
                                                    next
                                                      case pub
                                                      step( solve( !KU( idSN ) @ #vk.17 ) )
                                                        case c_KDF
                                                        by sorry
                                                      next
                                                        case c_SHA256
                                                        by sorry
                                                      next
                                                        case c_adec
                                                        by sorry
                                                      next
                                                        case c_aenc
                                                        by sorry
                                                      next
                                                        case c_f1
                                                        by sorry
                                                      next
                                                        case c_f1_star
                                                        by sorry
                                                      next
                                                        case c_f2
                                                        by sorry
                                                      next
                                                        case c_f3
                                                        by sorry
                                                      next
                                                        case c_f4
                                                        by sorry
                                                      next
                                                        case c_f5
                                                        by sorry
                                                      next
                                                        case c_f5_star
                                                        by sorry
                                                      next
                                                        case c_fst
                                                        by sorry
                                                      next
                                                        case c_pair
                                                        by sorry
                                                      next
                                                        case c_pk
                                                        by sorry
                                                      next
                                                        case c_snd
                                                        by sorry
                                                      next
                                                        case c_union
                                                        by sorry
                                                      next
                                                        case c_xor
                                                        by sorry
                                                      next
                                                        case c_zero
                                                        by sorry
                                                      next
                                                        case coerce
                                                        by sorry
                                                      next
                                                        case fresh
                                                        by sorry
                                                      next
                                                        case pub
                                                        step( solve( !KU( $x ) @ #vk.17 ) )
                                                          case pub
                                                          step( solve( !KU( idSN.1 ) @ #vk.18 ) )
                                                            case c_KDF
                                                            by sorry
                                                          next
                                                            case c_SHA256
                                                            by sorry
                                                          next
                                                            case c_adec
                                                            by sorry
                                                          next
                                                            case c_aenc
                                                            by sorry
                                                          next
                                                            case c_f1
                                                            by sorry
                                                          next
                                                            case c_f1_star
                                                            by sorry
                                                          next
                                                            case c_f2
                                                            by sorry
                                                          next
                                                            case c_f3
                                                            by sorry
                                                          next
                                                            case c_f4
                                                            by sorry
                                                          next
                                                            case c_f5
                                                            by sorry
                                                          next
                                                            case c_f5_star
                                                            by sorry
                                                          next
                                                            case c_fst
                                                            by sorry
                                                          next
                                                            case c_pair
                                                            by sorry
                                                          next
                                                            case c_pk
                                                            by sorry
                                                          next
                                                            case c_snd
                                                            by sorry
                                                          next
                                                            case c_union
                                                            by sorry
                                                          next
                                                            case c_xor
                                                            by sorry
                                                          next
                                                            case c_zero
                                                            by sorry
                                                          next
                                                            case coerce
                                                            by sorry
                                                          next
                                                            case fresh
                                                            by sorry
                                                          next
                                                            case pub
                                                            step( solve( !KU( $x.1 ) @ #vk.18 ) )
                                                              case pub
                                                              step( solve( !KU( conc_supi
                                                                           ) @ #vk.19 ) )
                                                                case c_KDF
                                                                by sorry
                                                              next
                                                                case c_SHA256
                                                                by sorry
                                                              next
                                                                case c_adec
                                                                by sorry
                                                              next
                                                                case c_aenc
                                                                by sorry
                                                              next
                                                                case c_f1
                                                                by sorry
                                                              next
                                                                case c_f1_star
                                                                by sorry
                                                              next
                                                                case c_f2
                                                                by sorry
                                                              next
                                                                case c_f3
                                                                by sorry
                                                              next
                                                                case c_f4
                                                                by sorry
                                                              next
                                                                case c_f5
                                                                by sorry
                                                              next
                                                                case c_f5_star
                                                                by sorry
                                                              next
                                                                case c_fst
                                                                by sorry
                                                              next
                                                                case c_pair
                                                                by sorry
                                                              next
                                                                case c_pk
                                                                by sorry
                                                              next
                                                                case c_snd
                                                                by sorry
                                                              next
                                                                case c_union
                                                                by sorry
                                                              next
                                                                case c_xor
                                                                by sorry
                                                              next
                                                                case c_zero
                                                                by sorry
                                                              next
                                                                case coerce
                                                                by sorry
                                                              next
                                                                case fresh
                                                                step( solve( !KU( ~x.2
                                                                             ) @ #vk.19 ) )
                                                                  case fresh
                                                                  by ATTACK // trace found
                                                                qed
                                                              next
                                                                case pub
                                                                by sorry
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case ue_send_attachReq_case_1
                                              by sorry
                                            next
                                              case ue_send_attachReq_case_2
                                              by sorry
                                            qed
                                          next
                                            case hss_receive_air_send_aia
                                            by sorry
                                          qed
                                        next
                                          case hss_receive_air_send_aia
                                          by sorry
                                        qed
                                      next
                                        case d_xor_case_1
                                        by sorry
                                      next
                                        case d_xor_case_2
                                        by sorry
                                      next
                                        case d_xor_case_3
                                        by step( contradiction )
                                      next
                                        case d_xor_case_4
                                        by sorry
                                      qed
                                    next
                                      case d_0_snd
                                      by sorry
                                    qed
                                  qed
                                next
                                  case d_0_snd
                                  by step( contradiction )
                                qed
                              next
                                case receive_secure_case_2
                                by sorry
                              qed
                            qed
                          qed
                        next
                          case ue_receive_authReq_fail_freshness_send_sync_failure
                          by sorry
                        next
                          case ue_receive_authReq_freshness_success_send_authResp
                          by sorry
                        next
                          case ue_send_attachReq
                          by sorry
                        qed
                      qed
                    next
                      case receive_secure_case_3
                      by sorry
                    qed
                  qed
                qed
              qed
            next
              case split_case_2
              by sorry
            next
              case split_case_3
              by sorry
            next
              case split_case_4
              by sorry
            qed
          qed
        qed
      next
        case supi_supply_case_2
        by sorry
      qed
    next
      case ue_send_attachReq_case_2
      by sorry
    qed
  next
    case RHS
    step( simplify )
    step( solve( St_1_UE( ~tid, ~supi, ~idHN, ~k, ~sqn_root ) ▶₀ #i ) )
      case ue_send_attachReq_case_1
      step( solve( SUPI( ~supi ) ▶₂ #i ) )
        case supi_supply
        step( solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count
                     ) ▶₁ #i ) )
          case add_subscription
          by sorry
        next
          case ue_receive_authReq_fail_freshness_send_sync_failure
          by step( contradiction )
        qed
      qed
    next
      case ue_send_attachReq_case_2
      step( solve( SUPI( ~supi ) ▶₂ #i ) )
        case supi_supply
        step( solve( Sqn_UE( ~supi, ~idHN, SqnUE, ~sqn_root, count
                     ) ▶₁ #i ) )
          case add_subscription
          step( solve( !KU( '1' ) @ #vk.9 ) )
            case coerce
            step( solve( !KU( '5G' ) @ #vk.8 ) )
              case coerce
              step( solve( !KD( '1' ) ▶₀ #vk.4 ) )
                case init_homeNet
                by step( contradiction )
              next
                case init_servNet
                by step( contradiction )
              next
                case seaf_receive_aca
                step( solve( !KD( '5G' ) ▶₀ #vk.5 ) )
                  case init_homeNet
                  by step( contradiction )
                next
                  case init_servNet
                  by step( contradiction )
                next
                  case seaf_receive_aca
                  step( solve( splitEqs(0) ) )
                    case split_case_1
                    by sorry
                  next
                    case split_case_2
                    by sorry
                  next
                    case split_case_3
                    by sorry
                  next
                    case split_case_4
                    by sorry
                  qed
                next
                  case seaf_receive_aia_send_authReq
                  by sorry
                next
                  case ue_receive_authReq_fail_freshness_send_sync_failure
                  by step( contradiction )
                next
                  case ue_receive_authReq_freshness_success_send_authResp
                  by step( contradiction )
                next
                  case ue_send_attachReq
                  by sorry
                qed
              next
                case seaf_receive_aia_send_authReq
                by sorry
              next
                case ue_receive_authReq_fail_freshness_send_sync_failure
                by sorry
              next
                case ue_receive_authReq_freshness_success_send_authResp
                by sorry
              next
                case ue_send_attachReq
                by sorry
              qed
            next
              case pub
              by sorry
            qed
          next
            case pub
            by sorry
          qed
        next
          case ue_receive_authReq_fail_freshness_send_sync_failure
          by step( contradiction )
        qed
      qed
    qed
  qed
next
  case Rule_ue_receive_authReq_freshness_success_send_authResp
  by sorry
next
  case Rule_ue_send_attachReq
  by sorry
qed

/* All well-formedness checks were successful. */

end